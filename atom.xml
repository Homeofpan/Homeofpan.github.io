<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Homeofpan.github.io/"/>
  <updated>2019-10-20T04:26:37.888Z</updated>
  <id>http://Homeofpan.github.io/</id>
  
  <author>
    <name>pan tao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mybatis源码分析三-动态代理对象MapperProxy的获取</title>
    <link href="http://Homeofpan.github.io/2019/10/20/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%89-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1MapperProxy%E7%9A%84%E8%8E%B7%E5%8F%96/"/>
    <id>http://Homeofpan.github.io/2019/10/20/mybatis源码分析三-动态代理对象MapperProxy的获取/</id>
    <published>2019-10-20T04:01:59.000Z</published>
    <updated>2019-10-20T04:26:37.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一开始-对方向你丢一张图-什么都不说-开始看图"><a href="#一开始-对方向你丢一张图-什么都不说-开始看图" class="headerlink" title="一开始,对方向你丢一张图,什么都不说,开始看图"></a>一开始,对方向你丢一张图,什么都不说,开始看图</h3><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图:"></a>流程图:</h3><p><img src="http://106.15.204.187:8888/group1/M00/00/00/rBEKH12r27-ARoqvAACz3Ym_DLo796.png" alt></p><h3 id="实验关键代码"><a href="#实验关键代码" class="headerlink" title="实验关键代码:"></a>实验关键代码:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法就是通过传入的接口类型获取一个jdk动态代理的MapperProxy对象</span></span><br><span class="line">IStudentDao mapperProxy = sqlSession.getMapper(IStudentDao.class);</span><br></pre></td></tr></table></figure><h3 id="进入sqlSession-getMapper-Class"><a href="#进入sqlSession-getMapper-Class" class="headerlink" title="进入sqlSession.getMapper(Class):"></a>进入sqlSession.getMapper(Class<t>):</t></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取资源都是从Configuration这个类的实例对象中获取</span></span><br><span class="line"><span class="comment">//从此可见其重要性</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> configuration.getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再进入configuration-getMapper-type-SqlSession"><a href="#再进入configuration-getMapper-type-SqlSession" class="headerlink" title="再进入configuration.getMapper(type, SqlSession):"></a>再进入configuration.getMapper(type, SqlSession):</h3><h3 id="这里使用了未委托模式-方法调用者虽然是Configuration对象-但是实质是调用Configuration对象里面成员变量的MapperRegistry的getMapper方法"><a href="#这里使用了未委托模式-方法调用者虽然是Configuration对象-但是实质是调用Configuration对象里面成员变量的MapperRegistry的getMapper方法" class="headerlink" title="这里使用了未委托模式,方法调用者虽然是Configuration对象,但是实质是调用Configuration对象里面成员变量的MapperRegistry的getMapper方法"></a>这里使用了未委托模式,方法调用者虽然是Configuration对象,但是实质是调用Configuration对象里面成员变量的MapperRegistry的getMapper方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapperRegistry-getMapper-type-sqlSession"><a href="#mapperRegistry-getMapper-type-sqlSession" class="headerlink" title="mapperRegistry.getMapper(type, sqlSession):"></a>mapperRegistry.getMapper(type, sqlSession):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据对应的接口类型获取mapperProxyFactory代理工厂</span></span><br><span class="line">    <span class="comment">//获取的方式就是根据之前在解析Mapper文件时,Mapper在Mapper注册中心时,将Class对象为key,value为代理工厂</span></span><br><span class="line">    <span class="comment">//put进去MapperRegistry里面的knownMappers的HashMap中</span></span><br><span class="line">    <span class="comment">//现在获取就肯定通过get(key)方法来获取mapperProxyFactory</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="真正获取MapperProxy的方法"><a href="#真正获取MapperProxy的方法" class="headerlink" title="真正获取MapperProxy的方法:"></a>真正获取MapperProxy的方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">  <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一开始-对方向你丢一张图-什么都不说-开始看图&quot;&gt;&lt;a href=&quot;#一开始-对方向你丢一张图-什么都不说-开始看图&quot; class=&quot;headerlink&quot; title=&quot;一开始,对方向你丢一张图,什么都不说,开始看图&quot;&gt;&lt;/a&gt;一开始,对方向你丢一张图,什么都不
      
    
    </summary>
    
    
      <category term="ssm" scheme="http://Homeofpan.github.io/categories/ssm/"/>
    
    
      <category term="mybatis" scheme="http://Homeofpan.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析2-获取SqlSessionFactory和SqlSession</title>
    <link href="http://Homeofpan.github.io/2019/10/19/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902-%E8%8E%B7%E5%8F%96SqlSessionFactory%E5%92%8CSqlSession/"/>
    <id>http://Homeofpan.github.io/2019/10/19/mybatis源码分析2-获取SqlSessionFactory和SqlSession/</id>
    <published>2019-10-19T07:25:30.000Z</published>
    <updated>2019-10-19T13:17:54.226Z</updated>
    
    <content type="html"><![CDATA[<p>流程图:</p><p><img src="http://106.15.204.187:8888/group1/M00/00/00/rBEKH12rDMuAQXQ-AADJ2HxnDTA060.png" alt></p><h3 id="一-实验关键代码"><a href="#一-实验关键代码" class="headerlink" title="一.实验关键代码"></a>一.实验关键代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载主配置文件</span></span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatisConfig.xml"</span>);</span><br><span class="line"><span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure><h2 id="二-创建SqlSessionFactory对象"><a href="#二-创建SqlSessionFactory对象" class="headerlink" title="二.创建SqlSessionFactory对象"></a>二.创建SqlSessionFactory对象</h2><h3 id="进入build-方法"><a href="#进入build-方法" class="headerlink" title="进入build()方法"></a>进入build()方法</h3><p>​                可以发现build()方法是一个重载方法.这个重载方式是拿来创建SqlSessionFactory对象,而我们重点关注的是build(parser.parse())方法;</p><p>parser.parse()方法是将mybatis的主配置文件解析并包装为Configuration对象， <strong>注意：这个Configuration非常重要，会贯穿于整个mybatis的生命</strong> ,build(parser.parse())是用来创建SqlSessionFactory对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//创建一个xml解析器parser</span></span><br><span class="line">     XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">     <span class="comment">//关注这个parser.parse()方法,这个方法解析mybatis主配置文件,并包装为Configuration类,这个类会贯穿mybaits的各个流程</span></span><br><span class="line"> <span class="comment">//build()方法就去创建DefaultSqlSessionFactory</span></span><br><span class="line">     <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ErrorContext.instance().reset();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       inputStream.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="进入parse-方法"><a href="#进入parse-方法" class="headerlink" title="进入parse()方法:"></a>进入parse()方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标志位:标志xml解析器是否已经解析过</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> parsed;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    parsed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//获取&lt;configuration&gt;标签的信息,并且解析该标签下面的所有子标签</span></span><br><span class="line">    <span class="comment">//private final XPathParser parser; 这个变量是在创建XMLConfigBuilder的xml解析器时,自动创建的</span></span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="但是我们发现parser-evalNode-“-configuration”-这个方法只是获取到configuration标签的信息-并没有去解析子标签-所以我们继续进入parseConfiguration方法"><a href="#但是我们发现parser-evalNode-“-configuration”-这个方法只是获取到configuration标签的信息-并没有去解析子标签-所以我们继续进入parseConfiguration方法" class="headerlink" title="但是我们发现parser.evalNode(“/configuration”)这个方法只是获取到configuration标签的信息,并没有去解析子标签,所以我们继续进入parseConfiguration方法()"></a>但是我们发现parser.evalNode(“/configuration”)这个方法只是获取到configuration标签的信息,并没有去解析子标签,所以我们继续进入parseConfiguration方法()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*该方法对configuration的子标签进行解析,并且由于方法的顺序性,导致了在写xml标签时一定要遵循这个顺序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//issue #117 read properties first</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//解析properties标签</span></span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">      Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析typeAliases标签及其子标签,typeAliases这个标签是用来起别名的</span></span><br><span class="line">      <span class="comment">// 别名是用在那个叫啥mapper.xml文件里的resultType啊这些之类的,细的不说</span></span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//用来解析plugins标签的</span></span><br><span class="line">      <span class="comment">// plugins就是一个拦截器interceptor</span></span><br><span class="line">      <span class="comment">// 可以拦截Executor 、ParameterHandler 、ResultSetHandler 、StatementHandler</span></span><br><span class="line">      <span class="comment">// 的部分方法，处理我们自己的逻辑。</span></span><br><span class="line">      <span class="comment">// sql真正执行的地方是executor，ParameterHandler 是处理我们传入参数的，mybatis默认帮我们实现了不少的typeHandler</span></span><br><span class="line">      <span class="comment">// 当我们不显示配置typeHandler的时候，mybatis会根据参数类型自动选择合适的typeHandler执行，其实就是ParameterHandler</span></span><br><span class="line">      <span class="comment">// 在选择。</span></span><br><span class="line">      <span class="comment">// ResultSetHandler 就是处理返回结果的。</span></span><br><span class="line">      <span class="comment">// 这里是官网的介绍和使用 http://www.mybatis.org/mybatis-3/configuration.html#plugins</span></span><br><span class="line">      pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析environments标签及其子标签</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//解析自定义的Handler</span></span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//获取mappers标签的信息,并且解析mappers的子标签,这里很重要,实现了mapper接口与mapper.xml的映射</span></span><br><span class="line">      mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="由此可见-parseConfiguration-方法就是对mybatis的标签进行解析-并且可以看到xml文件标签的编写顺序是按照解析标签方法的顺序而定的"><a href="#由此可见-parseConfiguration-方法就是对mybatis的标签进行解析-并且可以看到xml文件标签的编写顺序是按照解析标签方法的顺序而定的" class="headerlink" title="由此可见,parseConfiguration()方法就是对mybatis的标签进行解析,并且可以看到xml文件标签的编写顺序是按照解析标签方法的顺序而定的"></a>由此可见,parseConfiguration()方法就是对mybatis的标签进行解析,并且可以看到xml文件标签的编写顺序是按照解析标签方法的顺序而定的</h3><h3 id="先从简单的标签分析开始吧"><a href="#先从简单的标签分析开始吧" class="headerlink" title="先从简单的标签分析开始吧"></a>先从简单的<properties resource="jdbc.properties">标签分析开始吧</properties></h3><h3 id="propertiesElement-XNode-context"><a href="#propertiesElement-XNode-context" class="headerlink" title="propertiesElement(XNode context)"></a>propertiesElement(XNode context)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">propertiesElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//判断该子标签是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面都是properties标签的一些属性值</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取子标签的name,value并且set进去properties对象中</span></span><br><span class="line">    Properties defaults = context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">//获取properties上面的resource的值,代表是配置文件的位置</span></span><br><span class="line">    String resource = context.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">    <span class="comment">//获取properties上面的url的值,不能够同时设置resource和url的值</span></span><br><span class="line">    String url = context.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了resource属性</span></span><br><span class="line">    <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//getResourceAsProperties通过resource的值获取对应的属性值并且封装成一个Properties对象,</span></span><br><span class="line">      <span class="comment">//原理是将配置文件中"="前面的作为key,后面的作为value,然后put进该对象</span></span><br><span class="line">      <span class="comment">//Properties extends Hashtable&lt;Object,Object&gt; 这个实际上是个Hashtable</span></span><br><span class="line">      defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">      defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将configuration对象中已配置的Properties属性与刚刚解析的融合</span></span><br><span class="line">    <span class="comment">// configuration这个对象会装载所解析mybatis配置文件的所有节点元素，这个对象很重要，一定要记着！！</span></span><br><span class="line">    <span class="comment">// 既然configuration对象用有一系列的get/set方法， 标志着我们可以使用java代码直接配置</span></span><br><span class="line">    <span class="comment">// 需要注意的是,getVariables()在第一次调用的时候,返回的是对象里面什么都没有(并不是null)</span></span><br><span class="line">    <span class="comment">// variables变量在configuration创建时是这么创建的:protected Properties variables = new Properties();</span></span><br><span class="line">    Properties vars = configuration.getVariables();</span><br><span class="line">    <span class="keyword">if</span> (vars != <span class="keyword">null</span>) &#123;</span><br><span class="line">      defaults.putAll(vars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置回XPathParser对象中,后面可能有用</span></span><br><span class="line">    parser.setVariables(defaults);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将最后设置完的Properties对象通过set方法设置回Configuration类中</span></span><br><span class="line">    configuration.setVariables(defaults);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析properties标签实际就是将属性配置文件中的key-value存放在一个Properties对象中-底层就是Hashtable中-并且将该对象set进configuration对象中"><a href="#解析properties标签实际就是将属性配置文件中的key-value存放在一个Properties对象中-底层就是Hashtable中-并且将该对象set进configuration对象中" class="headerlink" title="解析properties标签实际就是将属性配置文件中的key,value存放在一个Properties对象中,底层就是Hashtable中,并且将该对象set进configuration对象中."></a>解析properties标签实际就是将属性配置文件中的key,value存放在一个Properties对象中,底层就是Hashtable中,并且将该对象set进configuration对象中.</h3><h4 id="2-1-2-typeAliasesElement-解析typeAliases标签"><a href="#2-1-2-typeAliasesElement-解析typeAliases标签" class="headerlink" title="2.1.2 typeAliasesElement()解析typeAliases标签"></a><strong>2.1.2 typeAliasesElement()解析typeAliases标签</strong></h4><p>作用:就是给你的实体类创建一个别名,那么在Mapper.xml中使用就不会这么复杂</p><h3 id="进入typeAliasesElement-XNode-parent"><a href="#进入typeAliasesElement-XNode-parent" class="headerlink" title="进入typeAliasesElement(XNode parent)"></a>进入typeAliasesElement(XNode parent)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeAliasesElement</span><span class="params">(XNode parent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断该标签是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//循环遍历子标签</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">//判断子标签中是否存在&lt;package&gt;标签</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="comment">//获取&lt;package&gt;标签中的name的属性的值</span></span><br><span class="line">        String typeAliasPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法分为步:</span></span><br><span class="line"><span class="comment">         *      1.configuration.getTypeAliasRegistry()获取TypeAliasRegistry对象</span></span><br><span class="line"><span class="comment">         *      2.TypeAliasRegistry,用来存放某类注册的别名</span></span><br><span class="line"><span class="comment">         *  该类中有个typeAliases属性是一个HashMap,mybatis默认地注册了一些java中常用的基本类型,集合...</span></span><br><span class="line"><span class="comment">         *  的别名</span></span><br><span class="line"><span class="comment">         *      3.registerAliases(typeAliasPackage)该方法就是把对应包下面的类,以key为普通类名.value是该类的class对象就是调用HashMap的put()方法.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String alias = child.getStringAttribute(<span class="string">"alias"</span>);</span><br><span class="line">        String type = child.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">          <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error registering typeAlias for '"</span> + alias + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我要介绍的主要是"><a href="#我要介绍的主要是" class="headerlink" title="我要介绍的主要是"></a>我要介绍的主要是</h3><p><code>configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</code>方法。这个方法首先getTypeAliasRegistry()获取注册中心，这个注册中心其实就是有个属性是HashMap,用来存放别名与对应的class对象,获取到TypeAliasRegistry后就执行他的registerAliases(typeAliasPackage)方法<br><strong>下面是TypeAliasRegistry这个类的结构：</strong> <code>protected final TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();</code> 点进去TypeAliasRegistry看看这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeAliasRegistry</span> </span>&#123;</span><br><span class="line"><span class="comment">//这个就是存放别名和具体类映射关系的地方,是一个HashMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; TYPE_ALIASES = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//这里创建时默认注册了一堆包名,这里就是在mapper.xml里可以使用的那些别名</span></span><br><span class="line"><span class="comment">//这里的别名可以对应上官网上介绍的别名了,以后就不用苦逼的去官网找mybatis默认的java类型别名了,来这儿</span></span><br><span class="line"><span class="comment">//这是官网地址: http://www.mybatis.org/mybatis-3/configuration.html#typeAliases</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TypeAliasRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">registerAlias(<span class="string">"string"</span>, String.class);</span><br><span class="line">registerAlias(<span class="string">"byte"</span>, Byte.clas);</span><br><span class="line">registerAlias(<span class="string">"long"</span>, Long.class);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h3 id="进入重点方法-registerAliases-typeAliasPackage-这个方法不断地调用自己的重载方法"><a href="#进入重点方法-registerAliases-typeAliasPackage-这个方法不断地调用自己的重载方法" class="headerlink" title="进入重点方法:registerAliases(typeAliasPackage)这个方法不断地调用自己的重载方法"></a>进入重点方法:registerAliases(typeAliasPackage)这个方法不断地调用自己的重载方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAliases</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">  registerAliases(packageName, Object.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAliases</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> </span>&#123;</span><br><span class="line">  ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;&gt;();</span><br><span class="line">  <span class="comment">//将该包名下的所有类和子包下面的以".class"结尾的文件,并且通过classloader的loader方法创建出对应的class对象</span></span><br><span class="line">  <span class="comment">//并且添加到Set集合中</span></span><br><span class="line">  resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(superType), packageName);</span><br><span class="line">  <span class="comment">//由于同一个包下面的类时不可能相同的,所以这里获取得到的所有class对象的是一个set集合</span></span><br><span class="line">  Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; type : typeSet) &#123;</span><br><span class="line">    <span class="comment">// Ignore inner classes and interfaces (including package-info.java)</span></span><br><span class="line">    <span class="comment">// Skip also inner classes. See issue #6</span></span><br><span class="line">    <span class="comment">//如果该类是接口,是内部类,是成员属性时,就会被忽略</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123;</span><br><span class="line">      <span class="comment">//调用重载方法</span></span><br><span class="line">      registerAlias(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过反射获取该类的简答类名,默认是类名首字母小写</span></span><br><span class="line">  String alias = type.getSimpleName();</span><br><span class="line">  <span class="comment">//获取@Alias注解的类对象</span></span><br><span class="line">  Alias aliasAnnotation = type.getAnnotation(Alias.class);</span><br><span class="line">  <span class="comment">//由此看出注解是优先于类的简单类名</span></span><br><span class="line">  <span class="keyword">if</span> (aliasAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//以直接中的value属性的值为别名</span></span><br><span class="line">    alias = aliasAnnotation.value();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//继续撸自己的重载方法</span></span><br><span class="line">  registerAlias(alias, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册别名的实质,就是将key为别名,value为class对象put进去HashMap中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String alias, Class&lt;?&gt; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"The parameter alias cannot be null"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// issue #748</span></span><br><span class="line">  String key = alias.toLowerCase(Locale.ENGLISH);</span><br><span class="line">  <span class="keyword">if</span> (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != <span class="keyword">null</span> &amp;&amp; !typeAliases.get(key).equals(value)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"The alias '"</span> + alias + <span class="string">"' is already mapped to the value '"</span> + typeAliases.get(key).getName() + <span class="string">"'."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  typeAliases.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-以上是解析别名标签的过程-是以package子标签的过程-以另外一个子标签解析过程也是差不多的-只要基础知识打好-看懂是没问题的-记住-设置别名的底层原理是HashMap的put方法-key为别名-value为对应类的class对象-注解优先于子标签"><a href="#总结-以上是解析别名标签的过程-是以package子标签的过程-以另外一个子标签解析过程也是差不多的-只要基础知识打好-看懂是没问题的-记住-设置别名的底层原理是HashMap的put方法-key为别名-value为对应类的class对象-注解优先于子标签" class="headerlink" title="总结:以上是解析别名标签的过程,是以package子标签的过程,以另外一个子标签解析过程也是差不多的,只要基础知识打好,看懂是没问题的.记住:设置别名的底层原理是HashMap的put方法,key为别名,value为对应类的class对象.注解优先于子标签."></a>总结:以上是解析别名标签的过程,是以package子标签的过程,以另外一个子标签解析过程也是差不多的,只要基础知识打好,看懂是没问题的.记住:设置别名的底层原理是HashMap的put方法,key为别名,value为对应类的class对象.注解优先于子标签.</h3><h4 id="2-1-3-environmentsElement-解析environments标签"><a href="#2-1-3-environmentsElement-解析environments标签" class="headerlink" title="2.1.3 environmentsElement()解析environments标签"></a><strong>2.1.3 environmentsElement()解析environments标签</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析environments标签及其子标签</span></span><br><span class="line">environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br></pre></td></tr></table></figure><h3 id="进入environmentsElement-Xnode-方法"><a href="#进入environmentsElement-Xnode-方法" class="headerlink" title="进入environmentsElement(Xnode)方法:"></a>进入environmentsElement(Xnode)方法:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置运行环境 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--事务管理器  type="JDBC"表示使用JDBC默认的事务管理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--type="POOLED" mybatis默认的数据库连接池  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--连接DB资源的四要素  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.user&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里context的值为前面执行方法解析出来的节点environments</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//获取根节点的default属性的值,并且设置当前的environment的值等于default的值,</span></span><br><span class="line">      <span class="comment">//也就是设置当前的默认环境是default的值</span></span><br><span class="line">      environment = context.getStringAttribute(<span class="string">"default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环遍历子标签(子节点)</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : context.getChildren()) &#123;</span><br><span class="line">      <span class="comment">//获取子标签的id属性值</span></span><br><span class="line">      String id = child.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">      <span class="comment">//判断id的值与当前环境environment的变量是否相同</span></span><br><span class="line">      <span class="comment">//这个方法的目的:在实际开发中,可能使用不同的数据库进行开发,但是一次只能使用一种,但是子标签可以</span></span><br><span class="line">      <span class="comment">//配置多个,通过id这个属性来匹配当前是使用那个环境进行</span></span><br><span class="line">      <span class="comment">//为什么不去解析其他的标签?因为用不到啊~用不到的也加载那不是浪费了?</span></span><br><span class="line">      <span class="keyword">if</span> (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">        <span class="comment">//获取解析好transactionManager标签;事务mybatis有两种：JDBC 和 MANAGED,</span></span><br><span class="line">        <span class="comment">// 配置为JDBC则直接使用JDBC的事务，配置为MANAGED则是将事务托管给容器</span></span><br><span class="line">        <span class="comment">//获取transactionManager标签的type属性,并且获取该标签的所有子标签的name,value值,set进去Properties对象</span></span><br><span class="line">        <span class="comment">//并且以该type的属性值,作为别名的名称去别名注册中心找到对应的class对象,通过反射将该数据库事务工厂创建出来</span></span><br><span class="line">        TransactionFactory txFactory = transactionManagerElement(child.evalNode(<span class="string">"transactionManager"</span>));</span><br><span class="line">        <span class="comment">//与上面的原理一样</span></span><br><span class="line">        DataSourceFactory dsFactory = dataSourceElement(child.evalNode(<span class="string">"dataSource"</span>));</span><br><span class="line">        <span class="comment">//获取数据库连接池</span></span><br><span class="line">        DataSource dataSource = dsFactory.getDataSource();</span><br><span class="line">        <span class="comment">//用上面获取的属性来初始化Environment的内部类Builder</span></span><br><span class="line">        Environment.Builder environmentBuilder = <span class="keyword">new</span> Environment.Builder(id)</span><br><span class="line">            .transactionFactory(txFactory)</span><br><span class="line">            .dataSource(dataSource);</span><br><span class="line">        <span class="comment">//用environmentBuilder.build()方法来创建Environment对象,并且set进去Configuration对象中</span></span><br><span class="line">        configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上面解析environment中的前两个标签的方法原理都一样-下面就只分析第一个transactionManagerElement-XNode"><a href="#上面解析environment中的前两个标签的方法原理都一样-下面就只分析第一个transactionManagerElement-XNode" class="headerlink" title="上面解析environment中的前两个标签的方法原理都一样.下面就只分析第一个transactionManagerElement(XNode):"></a>上面解析environment中的前两个标签的方法原理都一样.下面就只分析第一个transactionManagerElement(XNode):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionFactory <span class="title">transactionManagerElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//获取标签的type属性</span></span><br><span class="line">    String type = context.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">    <span class="comment">//获取子标签的name,value的值,并且set进去Properties对象中</span></span><br><span class="line">    Properties props = context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">//根据type获取对应的class对象,其实type就是作为别名去找hashMap中找class对象,然后根据class对象实例化出</span></span><br><span class="line">    <span class="comment">//TransactionFactory对象,type对应的数据库事务工厂</span></span><br><span class="line">    TransactionFactory factory = (TransactionFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">    <span class="comment">//将上面的properties对象set进去该工厂</span></span><br><span class="line">    factory.setProperties(props);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Environment declaration requires a TransactionFactory."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-mapperElement-解析mappers标签"><a href="#2-1-3-mapperElement-解析mappers标签" class="headerlink" title="2.1.3 mapperElement()解析mappers标签"></a><strong>2.1.3 mapperElement()解析mappers标签</strong></h4><h3 id="又再次说到这个标签的解析和映射"><a href="#又再次说到这个标签的解析和映射" class="headerlink" title="又再次说到这个标签的解析和映射"></a>又再次说到这个标签的解析和映射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//解析mappers标签及其子标签</span></span><br><span class="line">  <span class="comment">// 在这里会完成interface与mapper的映射</span></span><br><span class="line"><span class="comment">//&lt;mappers&gt;</span></span><br><span class="line"><span class="comment">//&lt;mapper resource="dao/mapper2.xml" /&gt;</span></span><br><span class="line"><span class="comment">//&lt;mapper class="com.dy.dao.UserDao"/&gt;</span></span><br><span class="line"><span class="comment">//&lt;mapper url="file://........"/&gt;</span></span><br><span class="line"><span class="comment">//&lt;package name="dao"/&gt;</span></span><br><span class="line"><span class="comment">//&lt;/mappers&gt;</span></span><br><span class="line">  <span class="comment">//parent的节点就是上一个方法所得到的节点为mappers</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">          <span class="comment">//如果mappers节点的子节点是package, 那么就扫描package下的文件, 丢进configuration</span></span><br><span class="line">          <span class="comment">//我们主要讲这种情况,其他三种情况其实都是一个鸟样,一通百通</span></span><br><span class="line">          <span class="comment">//获取标签里制定的包名（name字段的值）</span></span><br><span class="line">          String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">          <span class="comment">//看吧，又是一个往configuration丢东西的方法。此方法就是用来添加mapper的</span></span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果是mapper标签就获取它域的值,域的可能有三种:resource,url,class</span></span><br><span class="line">          String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">          String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">          String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">          <span class="comment">//三选一</span></span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里是resource</span></span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            <span class="comment">//mapper映射文件都是通过XMLMapperBuilder解析</span></span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource,</span><br><span class="line">              configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里是url</span></span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url,</span><br><span class="line">              configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里是class</span></span><br><span class="line">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//选不到就丢错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(</span><br><span class="line">              <span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="现在我们重点考虑package方式的解析mapper-xml的过程-因为这样就能节省多次写同样的标签的次数"><a href="#现在我们重点考虑package方式的解析mapper-xml的过程-因为这样就能节省多次写同样的标签的次数" class="headerlink" title="现在我们重点考虑package方式的解析mapper.xml的过程,因为这样就能节省多次写同样的标签的次数"></a>现在我们重点考虑package方式的解析mapper.xml的过程,因为这样就能节省多次写同样的标签的次数</h3><h3 id="configuration-addMappers-mapperPackage-方法"><a href="#configuration-addMappers-mapperPackage-方法" class="headerlink" title="configuration.addMappers(mapperPackage)方法"></a>configuration.addMappers(mapperPackage)方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用mapperRegistry.addMappers方法</span></span><br><span class="line">  mapperRegistry.addMappers(packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，mapperRegistry是什么，没错就是Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">跟进去看看MapperRegistry</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line"><span class="comment">// 这个map存放的是每一种接口对应的MapperProxyFactory</span></span><br><span class="line"><span class="comment">//key:interface(当然也可以是类,但是按规定来的话应该是接口); value:MapperProxyFactory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继续跟进-mapperRegistry-addMappers-packageName-方法"><a href="#继续跟进-mapperRegistry-addMappers-packageName-方法" class="headerlink" title="继续跟进 mapperRegistry.addMappers(packageName)方法"></a>继续跟进 mapperRegistry.addMappers(packageName)方法</h3><p>又是一个重复调用的重载方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">  addMappers(packageName, Object.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//new 一个解析工具类</span></span><br><span class="line">  ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;&gt;();</span><br><span class="line">  <span class="comment">//将packName包和子包的所有文件都进行搜索,如果发现文件以".class"结尾的文件,则以classloader的方式创建class对象并且存放到set集合中</span></span><br><span class="line">  resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(superType), packageName);</span><br><span class="line">  <span class="comment">//获取Set集合中的所有class对象</span></span><br><span class="line">  Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">    <span class="comment">//将mapperClass注册到MapperRegister里面,并且进行了mapper.xml解析和与mapper接口的映射</span></span><br><span class="line">    addMapper(mapperClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断该类是否为interface</span></span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">    <span class="comment">//如果该Mapper已经加载过则报错</span></span><br><span class="line">    <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记位: 标志是否加载完成,用于反正加载过程中出异常之后,没有把已经put进去的key,value及时地删除,防止占用内存</span></span><br><span class="line">    <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//knownMappers是一个HashMap用来存放已经加载过的Mapper接口</span></span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">      <span class="comment">// It's important that the type is added before the parser is run</span></span><br><span class="line">      <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">      <span class="comment">// mapper parser. If the type is already known, it won't try.</span></span><br><span class="line">      <span class="comment">//创建Mapper接口的注解解析器parser,先对xml解析之后再对注解进行解析,这样就实现了注解优于xml执行</span></span><br><span class="line">      MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">      <span class="comment">//解析sql语句</span></span><br><span class="line">      parser.parse();</span><br><span class="line">      <span class="comment">//设置成功加载完的标志位</span></span><br><span class="line">      loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//保证无论是否异常都必须执行对加载结果的检查,防止异常的发生</span></span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进入parse方法-解析xml和注解的sql语句"><a href="#进入parse方法-解析xml和注解的sql语句" class="headerlink" title="进入parse方法:解析xml和注解的sql语句"></a>进入parse方法:解析xml和注解的sql语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是注解解析器的parse的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取接口的全限定类名</span></span><br><span class="line">  String resource = type.toString();</span><br><span class="line">  <span class="comment">//判断这个类是否已经加载过了,防止二次加载</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">//加载和解析mapper.xml文件</span></span><br><span class="line">    loadXmlResource();</span><br><span class="line">    <span class="comment">//标志mapper接口已经成功加载</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    assistant.setCurrentNamespace(type.getName());</span><br><span class="line">    parseCache();</span><br><span class="line">    parseCacheRef();</span><br><span class="line">    <span class="comment">//获取mapper接口的所有方法</span></span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// issue #237</span></span><br><span class="line">        <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">          <span class="comment">//根据方法名来解析sql语句</span></span><br><span class="line">          parseStatement(method);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">        configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理一些出现异常的Method</span></span><br><span class="line">  parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这里有个重要的方法loadXmlResource-说明了为什么要使用package的方式加载xml时文件名要和mapper的接口名一样"><a href="#这里有个重要的方法loadXmlResource-说明了为什么要使用package的方式加载xml时文件名要和mapper的接口名一样" class="headerlink" title="这里有个重要的方法loadXmlResource():说明了为什么要使用package的方式加载xml时文件名要和mapper的接口名一样"></a>这里有个重要的方法loadXmlResource():说明了为什么要使用package的方式加载xml时文件名要和mapper的接口名一样</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadXmlResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Spring may not know the real resource name so we check a flag</span></span><br><span class="line">  <span class="comment">// to prevent loading again a resource twice</span></span><br><span class="line">  <span class="comment">// this flag is set at XMLMapperBuilder#bindMapperForNamespace</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(<span class="string">"namespace:"</span> + type.getName())) &#123;</span><br><span class="line">    <span class="comment">//用mapper接口的全限定类名与".xml"拼接,获取mapper.xml的文件名</span></span><br><span class="line">    <span class="comment">//这就是为什么使用package的时候要求mapper.xml的名称要与mapper接口名称一样</span></span><br><span class="line">    String xmlResource = type.getName().replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".xml"</span>;</span><br><span class="line">    <span class="comment">// #1347</span></span><br><span class="line">    InputStream inputStream = type.getResourceAsStream(<span class="string">"/"</span> + xmlResource);</span><br><span class="line">    <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Search XML mapper that is not in the module but in the classpath.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果不存在的话就去classpath下面找相同名称的文件进行加载</span></span><br><span class="line">        inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">        <span class="comment">// ignore, resource is not required</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//如果文件存在的话,就在这里进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">      XMLMapperBuilder xmlParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());</span><br><span class="line">      <span class="comment">//解析mapper.xml</span></span><br><span class="line">      xmlParser.parse();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进入xmlParser-parse-解析mapper-xml"><a href="#进入xmlParser-parse-解析mapper-xml" class="headerlink" title="进入xmlParser.parse():解析mapper.xml"></a>进入xmlParser.parse():解析mapper.xml</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">//先获取&lt;mapper标签的所有信息&gt;,然后再对mapper下面的子标签进行解析</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">    <span class="comment">//将该mapper.xml加载到已经加载过的资源里面,标志该文件已经解析完成</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">//namespace处理</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里的执行的方法是一些特殊判处异常的resultMaps,statements,cacheRefs</span></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再深入的方法这里就不放了，差不多就得了。需要注意的一点就是，如果使用的是package标签来扫描mapper文件，那么mapper文件的文件名必须要和接口名相同，并且放在同一个包下（或者直接放在classpath下）。而另三种扫描mapper的方式只需要命名空间与接口全限定名相同。为什么呢？在上面代码中的loadXmlResource-方法里面会给你一个满意的解释，看懂了package为什么要相同，那么另外三种也不在话下，猜也猜得出。注释我也打上了，看就得了。"><a href="#再深入的方法这里就不放了，差不多就得了。需要注意的一点就是，如果使用的是package标签来扫描mapper文件，那么mapper文件的文件名必须要和接口名相同，并且放在同一个包下（或者直接放在classpath下）。而另三种扫描mapper的方式只需要命名空间与接口全限定名相同。为什么呢？在上面代码中的loadXmlResource-方法里面会给你一个满意的解释，看懂了package为什么要相同，那么另外三种也不在话下，猜也猜得出。注释我也打上了，看就得了。" class="headerlink" title="再深入的方法这里就不放了，差不多就得了。需要注意的一点就是，如果使用的是package标签来扫描mapper文件，那么mapper文件的文件名必须要和接口名相同，并且放在同一个包下（或者直接放在classpath下）。而另三种扫描mapper的方式只需要命名空间与接口全限定名相同。为什么呢？在上面代码中的loadXmlResource()方法里面会给你一个满意的解释，看懂了package为什么要相同，那么另外三种也不在话下，猜也猜得出。注释我也打上了，看就得了。"></a>再深入的方法这里就不放了，差不多就得了。需要注意的一点就是，如果使用的是package标签来扫描mapper文件，那么mapper文件的文件名必须要和接口名相同，并且放在同一个包下（或者直接放在classpath下）。而另三种扫描mapper的方式只需要命名空间与接口全限定名相同。为什么呢？在上面代码中的loadXmlResource()方法里面会给你一个满意的解释，看懂了package为什么要相同，那么另外三种也不在话下，猜也猜得出。注释我也打上了，看就得了。</h3><h3 id="2-2-创建SqlSessionFactory之build-parser-parse-方法"><a href="#2-2-创建SqlSessionFactory之build-parser-parse-方法" class="headerlink" title="2.2 创建SqlSessionFactory之build(parser.parse());方法"></a><strong>2.2 创建SqlSessionFactory之build(parser.parse());方法</strong></h3><p>虽然说上面的那个过程并不是我们最后想要的结果,但是知道了parser.parse()解析主配置文件的过程,并且最后一个结果封装成一个Configuration对象,这是发生在创建SqlSessionFactory的过程中,但是真正创建SqlSessionFactory的方法是build(parser.parse()),接下来我们要跟进去这个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个SqlSessionFactory的实现类DefaultSqlSessionFactory并且将解析主配置文件生成的config传入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="然后目的就达到了-成功获取到了SqlSessionFactory-DefaultSqlSessionFactory"><a href="#然后目的就达到了-成功获取到了SqlSessionFactory-DefaultSqlSessionFactory" class="headerlink" title="然后目的就达到了,成功获取到了SqlSessionFactory(DefaultSqlSessionFactory)"></a>然后目的就达到了,成功获取到了SqlSessionFactory(DefaultSqlSessionFactory)</h3><h3 id="3-回来到获取SqlSession"><a href="#3-回来到获取SqlSession" class="headerlink" title="**3.回来到获取SqlSession"></a>**3.回来到获取SqlSession</h3><h3 id="回到实验代码"><a href="#回到实验代码" class="headerlink" title="回到实验代码"></a>回到实验代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载主配置文件</span></span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatisConfig.xml"</span>);</span><br><span class="line"><span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure><h3 id="跟进sqlSessionFactory-openSession-来获取sqlSession"><a href="#跟进sqlSessionFactory-openSession-来获取sqlSession" class="headerlink" title="跟进sqlSessionFactory.openSession()来获取sqlSession"></a>跟进sqlSessionFactory.openSession()来获取sqlSession</h3><h3 id="这又是一个重载方法"><a href="#这又是一个重载方法" class="headerlink" title="这又是一个重载方法"></a>这又是一个重载方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//参数2:代表事务的隔离级别</span></span><br><span class="line">  <span class="comment">//参数3:代表是否自动提交事务</span></span><br><span class="line">  <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configuration.getDefaultExecutorType()这是什么鬼东西??????点进去看一下,是一个ExecutorType类型的形参</p><p> ExecutorType.SIMPLE又是一个不懂的东西?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutorType &#123;</span><br><span class="line">  SIMPLE, REUSE, BATCH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这是一个简单的枚举-代表的是执行器种类-这个在下一个文章介绍如何执行sql的时候才能将到Executor-所以下篇文章再来探讨"><a href="#这是一个简单的枚举-代表的是执行器种类-这个在下一个文章介绍如何执行sql的时候才能将到Executor-所以下篇文章再来探讨" class="headerlink" title="这是一个简单的枚举,代表的是执行器种类,这个在下一个文章介绍如何执行sql的时候才能将到Executor,所以下篇文章再来探讨"></a>这是一个简单的枚举,代表的是执行器种类,这个在下一个文章介绍如何执行sql的时候才能将到Executor,所以下篇文章再来探讨</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//真正的获取sqlSession，这个SqlSession里面需要配置类configuration，执行器executor，是否提交标志autoCommit</span></span><br><span class="line"><span class="comment">//executor里面需要事务tx，执行器类型execType，默认为ExecutorType.SIMPLE</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新事务</span></span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="comment">//从environment里获取事务，这个没毛病吧？environment标签里有什么来着？</span></span><br><span class="line">      <span class="comment">//&lt;transactionManager type="JDBC" /&gt;</span></span><br><span class="line">      <span class="comment">//&lt;dataSource type="POOLED"&gt; ... &lt;/dataSource&gt;</span></span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">//获取sql语句的Executor(执行器),根据execType来获取对应类型的执行器</span></span><br><span class="line">      <span class="comment">//一共有三种Executor,并且都是继承BaseExecutor的</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="comment">//返回DefaultSqlSession对象,SqlSession的实现类</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="comment">//防止在已经获取了连接之后,执行过程中出现了异常,被捕获了,要将该连接给关闭,不然就会造成资源的浪费,影响程序的性能</span></span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>到此为止，SqlSession获取完成。获取SqlSession过程比创建SqlSessionFactory简单多了，只要从configuration中获取到要用的东西就行了。<br>说到这里不得不再次提一下，Configuration非常非常重要！对于mybatis的所有配置和属性，几乎都在这里了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;流程图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://106.15.204.187:8888/group1/M00/00/00/rBEKH12rDMuAQXQ-AADJ2HxnDTA060.png&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;一-实验关键代码&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
    
      <category term="mybatis" scheme="http://Homeofpan.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析1--环境搭建</title>
    <link href="http://Homeofpan.github.io/2019/10/19/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://Homeofpan.github.io/2019/10/19/mybatis源码分析1-环境搭建/</id>
    <published>2019-10-19T07:01:42.000Z</published>
    <updated>2019-10-19T07:15:28.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis源码运行流程分析之搭建环境"><a href="#mybatis源码运行流程分析之搭建环境" class="headerlink" title="mybatis源码运行流程分析之搭建环境"></a><strong>mybatis源码运行流程分析之搭建环境</strong></h1><p>本文分析用的是mybatis-3.5.0，jdk-1.8，maven-3.6.0</p><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件:"></a>pom文件:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据-建表"><a href="#数据-建表" class="headerlink" title="数据+建表:"></a>数据+建表:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student1` (</span><br><span class="line">  `id` int(5) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) DEFAULT NULL,</span><br><span class="line">  `age` int(3) DEFAULT NULL,</span><br><span class="line">  `score` double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of student</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `student` VALUES (&apos;1&apos;, &apos;a&apos;, &apos;2&apos;, &apos;3&apos;);</span><br><span class="line">INSERT INTO `student` VALUES (&apos;2&apos;, &apos;b&apos;, &apos;2&apos;, &apos;3&apos;);</span><br><span class="line">INSERT INTO `student` VALUES (&apos;3&apos;, &apos;张三&apos;, &apos;23&apos;, &apos;93.5&apos;);</span><br><span class="line">INSERT INTO `student` VALUES (&apos;4&apos;, &apos;张三-1&apos;, &apos;23&apos;, &apos;93.5&apos;);</span><br></pre></td></tr></table></figure><h3 id="Pojo-java对象"><a href="#Pojo-java对象" class="headerlink" title="Pojo(java对象)"></a>Pojo(java对象)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....get,set方法 toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dao接口"><a href="#dao接口" class="headerlink" title="dao接口:"></a>dao接口:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dao的实现类"><a href="#dao的实现类" class="headerlink" title="dao的实现类:"></a>dao的实现类:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pan.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pan.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by pan tao on 2019/10/19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IStudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">IStudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"==========&gt; 现在使用的是dao的手动实现类"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载主配置文件</span></span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatisConfig.xml"</span>);</span><br><span class="line">            <span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">            SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">            sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">            <span class="comment">//相关操作</span></span><br><span class="line">            sqlSession.insert(<span class="string">"Pan.insertStudent"</span>, student);</span><br><span class="line"><span class="comment">//sqlSession.insert("insertStudent", student);</span></span><br><span class="line">            sqlSession.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sqlSession.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========&gt; 现在使用的是dao的手动实现类"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//加载主配置文件</span></span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatisConfig.xml"</span>);</span><br><span class="line">            <span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">            SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">            sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">            <span class="comment">//相关操作</span></span><br><span class="line">            Student student = (Student) sqlSession.selectList(<span class="string">"Pan.selectById"</span>, id).get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//sqlSession.insert("insertStudent", student);</span></span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sqlSession.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbc-properties"><a href="#jdbc-properties" class="headerlink" title="jdbc.properties"></a>jdbc.properties</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//127.0.0.1:3306/test</span></span><br><span class="line">jdbc.user=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties:"></a>log4j.properties:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target = System.out</span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern = [%-5p] [%d&#123;yyyy-MM-dd HH:mm:ss&#125;] %c  %L %m%n</span><br><span class="line">log4j.logger.com.pan.dao.ICountryDao= debug,stdout</span><br></pre></td></tr></table></figure><h3 id="mybatisConfig-xml"><a href="#mybatisConfig-xml" class="headerlink" title="mybatisConfig.xml"></a>mybatisConfig.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册连接DB四要素的配置文件  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认将这个包里的所有的简单类名当做别名  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.pan.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--类型处理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当配置package的时候，mybatis会去配置的package扫描TypeHandler --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;package name="con.pan.handle" /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- handler属性直接配置我们要指定的TypeHandler --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;typeHandler handler=""/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- javaType 配置java类型，例如String, 如果配上javaType, 那么指定的typeHandler就只作用于指定的类型 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;typeHandler javaType="" handler=""/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- jdbcType 配置数据库基本数据类型，例如varchar, 如果配上jdbcType, 那么指定的typeHandler就只作用于指定的类型 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;typeHandler jdbcType="" handler=""/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 也可两者都配置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;typeHandler javaType="" jdbcType="" handler=""/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com.pan.handler.MyHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自定义插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.pan.plugins.ExamplePlugin"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置运行环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--事务管理器  type="JDBC"表示使用JDBC默认的事务管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--type="POOLED" mybatis默认的数据库连接池  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--连接DB资源的四要素  --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.user&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 注册映射文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper/StudentMapper.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper/StudentMapper2.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="StudentMapper-xml"><a href="#StudentMapper-xml" class="headerlink" title="StudentMapper.xml"></a>StudentMapper.xml</h3><p>为了测试使用动态代理和不用动态代理的区别所以创建了两个不同命名空间的mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"Pan"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertStudent"</span> <span class="attr">parameterType</span>=<span class="string">"com.pan.pojo.Student"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--放sql语句,?放属性名  --&gt;</span></span><br><span class="line">        insert into student1(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"stuMap"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;result column="name" property="name" jdbcType="VARCHAR" /&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">typeHandler</span>=<span class="string">"com.pan.handler.MyHandler"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这句和上面的那句结果一样的&lt;result column="name" property="name" typeHandler="com.pan.handler.MyHandler"/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"score"</span> <span class="attr">property</span>=<span class="string">"score"</span> <span class="attr">jdbcType</span>=<span class="string">"DOUBLE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"stuMap"</span>&gt;</span></span><br><span class="line">        select * from student1 where id = #&#123;xxx&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="StudentMapper2-xml"><a href="#StudentMapper2-xml" class="headerlink" title="StudentMapper2.xml"></a>StudentMapper2.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.pan.dao.IStudentDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertStudent"</span> <span class="attr">parameterType</span>=<span class="string">"com.pan.pojo.Student"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--放sql语句,?放属性名  --&gt;</span></span><br><span class="line">        insert into student1(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"stuMap"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;result column="name" property="name" jdbcType="VARCHAR" /&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">typeHandler</span>=<span class="string">"com.pan.handler.MyHandler"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这句和上面的那句结果一样的&lt;result column="name" property="name" typeHandler="com.pan.handler.MyHandler"/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"score"</span> <span class="attr">property</span>=<span class="string">"score"</span> <span class="attr">jdbcType</span>=<span class="string">"DOUBLE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"stuMap"</span>&gt;</span></span><br><span class="line">        select * from student1 where id = #&#123;xxx&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MyHandler-自定义类型处理器"><a href="#MyHandler-自定义类型处理器" class="headerlink" title="MyHandler(自定义类型处理器)"></a>MyHandler(自定义类型处理器)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedJdbcTypes</span>(JdbcType.VARCHAR)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ps.setString(i, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rs.getString(columnName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rs.getString(columnIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.getString(columnIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义插件ExamplePlugin"><a href="#自定义插件ExamplePlugin" class="headerlink" title="自定义插件ExamplePlugin"></a>自定义插件ExamplePlugin</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pan.plugins;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by pan tao on 2019/10/19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.executor.Executor;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.mapping.MappedStatement;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.plugin.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.ResultHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.RowBounds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123; <span class="meta">@Signature</span>(type = Executor.class,</span><br><span class="line">        method = <span class="string">"query"</span>, <span class="comment">//这里要对应Executor.class里的方法，下面的参数就是具体方法的参数</span></span><br><span class="line">        args = &#123; MappedStatement.class, Object.class ,RowBounds.class, ResultHandler.class&#125;) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// implement pre processing if need</span></span><br><span class="line">        System.out.println(<span class="string">"============&gt; before method"</span>);</span><br><span class="line">        Object returnObject = invocation.proceed();</span><br><span class="line">        <span class="comment">// implement post processing if need</span></span><br><span class="line">        System.out.println(<span class="string">"============&gt; after method"</span>);</span><br><span class="line">        <span class="keyword">return</span> returnObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元测试MyTest"><a href="#单元测试MyTest" class="headerlink" title="单元测试MyTest"></a>单元测试MyTest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pan.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.pan.dao.IStudentDao;</span><br><span class="line"><span class="keyword">import</span> com.pan.dao.IStudentDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.pan.pojo.Student;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by pan tao on 2019/10/19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IStudentDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dao = <span class="keyword">new</span> IStudentDaoImpl();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"大吉吧"</span>,<span class="number">23</span>,<span class="number">96</span>);</span><br><span class="line">        dao.insertStudent(student);</span><br><span class="line">        System.out.println(<span class="string">"111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectStu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Student student = dao.selectById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过mapper动态代理来完成查询,实现所需</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByMapperProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//加载主配置文件</span></span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatisConfig.xml"</span>);</span><br><span class="line">        <span class="comment">//创建SqlSessionFactory对象</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        IStudentDao mapperProxy = sqlSession.getMapper(IStudentDao.class);</span><br><span class="line">        Student student = mapperProxy.selectById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mybatis源码运行流程分析之搭建环境&quot;&gt;&lt;a href=&quot;#mybatis源码运行流程分析之搭建环境&quot; class=&quot;headerlink&quot; title=&quot;mybatis源码运行流程分析之搭建环境&quot;&gt;&lt;/a&gt;&lt;strong&gt;mybatis源码运行流程分析之搭建
      
    
    </summary>
    
    
      <category term="ssm" scheme="http://Homeofpan.github.io/categories/ssm/"/>
    
    
      <category term="mybatis" scheme="http://Homeofpan.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mapper接口如何与mapper.xml进行映射</title>
    <link href="http://Homeofpan.github.io/2019/10/19/mapper%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E4%B8%8Emapper-xml%E8%BF%9B%E8%A1%8C%E6%98%A0%E5%B0%84/"/>
    <id>http://Homeofpan.github.io/2019/10/19/mapper接口如何与mapper-xml进行映射/</id>
    <published>2019-10-19T03:52:36.000Z</published>
    <updated>2019-10-19T05:31:04.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-手动使用mybatis进行测试"><a href="#一-手动使用mybatis进行测试" class="headerlink" title="一.手动使用mybatis进行测试:"></a>一.手动使用mybatis进行测试:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//加载主配置文件</span></span><br><span class="line">       InputStream is = Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">       <span class="keyword">if</span>(sqlSessionFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">           sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="进入SqlSessionFactoryBuilder-build-is-方法"><a href="#进入SqlSessionFactoryBuilder-build-is-方法" class="headerlink" title="进入SqlSessionFactoryBuilder().build(is)方法:"></a>进入SqlSessionFactoryBuilder().build(is)方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//获取一个xml配置文件的解析器,利用这个解析器去解析</span></span><br><span class="line">     XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">     <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ErrorContext.instance().reset();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       inputStream.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="进入XMLConfigBuilder的parse-方法-解析mybatis的主配置文件"><a href="#进入XMLConfigBuilder的parse-方法-解析mybatis的主配置文件" class="headerlink" title="进入XMLConfigBuilder的parse()方法: 解析mybatis的主配置文件"></a>进入XMLConfigBuilder的parse()方法: 解析mybatis的主配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回将xml主配置文件包装成一个java类型的对象Configuration</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否解析过</span></span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    parsed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//获取configuration标签下面所有的子标签,解析这些子标签</span></span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="进入parseConfiguration-XNode-root-的方法"><a href="#进入parseConfiguration-XNode-root-的方法" class="headerlink" title="进入parseConfiguration(XNode root)的方法:"></a>进入parseConfiguration(XNode root)的方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">//......省略部分代码,暂时还不需要</span></span><br><span class="line">    <span class="comment">//获取mappers标签的信息,然后解析mapper.xml文件,完成xml到java类型的映射</span></span><br><span class="line">     mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="进入进入mapperElement-root-evalNode-“mappers”-方法"><a href="#进入进入mapperElement-root-evalNode-“mappers”-方法" class="headerlink" title="进入进入mapperElement(root.evalNode(“mappers”))方法:"></a>进入进入mapperElement(root.evalNode(“mappers”))方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//parent:mappers作为父节点一样</span></span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//遍历所有的子标签</span></span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">//如果使用了&lt;package/&gt;标签的话,就走这个代码</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">//进行mapper.xml的解析</span></span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          <span class="comment">//这里是使用&lt;resource/&gt;标签的解析mapper.xml</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进入configuration-addMappers-mapperPackage-方法"><a href="#进入configuration-addMappers-mapperPackage-方法" class="headerlink" title="进入configuration.addMappers(mapperPackage)方法:"></a>进入configuration.addMappers(mapperPackage)方法:</h3><h4 id="1-该方法是将Mapper文件注册到MapperRegistry中"><a href="#1-该方法是将Mapper文件注册到MapperRegistry中" class="headerlink" title="1.该方法是将Mapper文件注册到MapperRegistry中"></a>1.该方法是将Mapper文件注册到MapperRegistry中</h4><h4 id="2-然后再将mapper的接口添加到MapperRegistry中-进入addMapper-mapperClass-方法"><a href="#2-然后再将mapper的接口添加到MapperRegistry中-进入addMapper-mapperClass-方法" class="headerlink" title="2.然后再将mapper的接口添加到MapperRegistry中,进入addMapper(mapperClass)方法;"></a>2.然后再将mapper的接口添加到MapperRegistry中,进入addMapper(mapperClass)方法;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">      <span class="comment">// It's important that the type is added before the parser is run</span></span><br><span class="line">      <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">      <span class="comment">// mapper parser. If the type is already known, it won't try.</span></span><br><span class="line">      MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">      <span class="comment">//这步进行真正的mapper.xml的解析</span></span><br><span class="line">      parser.parse();</span><br><span class="line">      loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进入parse-parese-方法"><a href="#进入parse-parese-方法" class="headerlink" title="进入parse.parese()方法:"></a>进入parse.parese()方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String resource = type.toString();</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">//加载xml文件并且解析</span></span><br><span class="line">    loadXmlResource();</span><br><span class="line">    <span class="comment">//....忽略一下代码</span></span><br><span class="line">  parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进入loadXmlResource-方法"><a href="#进入loadXmlResource-方法" class="headerlink" title="进入loadXmlResource()方法:"></a>进入loadXmlResource()方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadXmlResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Spring may not know the real resource name so we check a flag</span></span><br><span class="line">  <span class="comment">// to prevent loading again a resource twice</span></span><br><span class="line">  <span class="comment">// this flag is set at XMLMapperBuilder#bindMapperForNamespace</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(<span class="string">"namespace:"</span> + type.getName())) &#123;</span><br><span class="line">    <span class="comment">//从mapper接口下面对应的mapper接口的全限定类名加上.xml</span></span><br><span class="line">    String xmlResource = type.getName().replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".xml"</span>;</span><br><span class="line">    <span class="comment">// #1347</span></span><br><span class="line">    InputStream inputStream = type.getResourceAsStream(<span class="string">"/"</span> + xmlResource);</span><br><span class="line">    <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Search XML mapper that is not in the module but in the classpath.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果不存在的话就去classpath下面找这个文件</span></span><br><span class="line">        inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">        <span class="comment">// ignore, resource is not required</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">      XMLMapperBuilder xmlParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());</span><br><span class="line">      <span class="comment">//解析mapper.xml</span></span><br><span class="line">      xmlParser.parse();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进入xmlParser-parse-方法"><a href="#进入xmlParser-parse-方法" class="headerlink" title="进入xmlParser.parse()方法:"></a>进入xmlParser.parse()方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">//先获取&lt;mapper标签的所有信息&gt;,然后再对mapper下面的子标签进行解析</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//这里的执行的方法是一些特殊情况的resultMaps,statements,cacheRefs</span></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进入configurationElement-XNode-context-方法"><a href="#进入configurationElement-XNode-context-方法" class="headerlink" title="进入configurationElement(XNode context)方法:"></a>进入configurationElement(XNode context)方法:</h3><h4 id="进行mapper下各种标签的解析"><a href="#进行mapper下各种标签的解析" class="headerlink" title="进行mapper下各种标签的解析"></a>进行mapper下各种标签的解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><h3 id="1-mapper-xml解析"><a href="#1-mapper-xml解析" class="headerlink" title="1.mapper.xml解析:"></a>1.mapper.xml解析:</h3><p>org.apache.ibatis.builder.xml.XMLMapperBuilder.configurationElement(XNode);</p><h3 id="2-解析mybatis-xml的主配置文件"><a href="#2-解析mybatis-xml的主配置文件" class="headerlink" title="2.解析mybatis.xml的主配置文件:"></a>2.解析mybatis.xml的主配置文件:</h3><p>org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration(XNode);</p><h3 id="3-对xml文件的解析都对应着一个XMLxxxxBuilder"><a href="#3-对xml文件的解析都对应着一个XMLxxxxBuilder" class="headerlink" title="3.对xml文件的解析都对应着一个XMLxxxxBuilder."></a>3.对xml文件的解析都对应着一个XMLxxxxBuilder.</h3><h3 id="原理时序图"><a href="#原理时序图" class="headerlink" title="原理时序图:"></a>原理时序图:</h3><p><img src="http://106.15.204.187:8888/group1/M00/00/00/rBEKH12qnqaAC2VWAABx6ywtUgU838.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-手动使用mybatis进行测试&quot;&gt;&lt;a href=&quot;#一-手动使用mybatis进行测试&quot; class=&quot;headerlink&quot; title=&quot;一.手动使用mybatis进行测试:&quot;&gt;&lt;/a&gt;一.手动使用mybatis进行测试:&lt;/h3&gt;&lt;figure cla
      
    
    </summary>
    
    
      <category term="ssm" scheme="http://Homeofpan.github.io/categories/ssm/"/>
    
    
      <category term="mybatis" scheme="http://Homeofpan.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析一</title>
    <link href="http://Homeofpan.github.io/2019/10/15/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/"/>
    <id>http://Homeofpan.github.io/2019/10/15/mybatis源码分析一/</id>
    <published>2019-10-15T11:39:03.000Z</published>
    <updated>2019-10-16T15:18:15.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-xml和annotation同时使用哪个会生效"><a href="#一-xml和annotation同时使用哪个会生效" class="headerlink" title="一.xml和annotation同时使用哪个会生效"></a>一.xml和annotation同时使用哪个会生效</h2><p>当xml和annotation同时作用于同一个接口的方法时,annotation会生效,原因看下面源码的分析:</p><p>这里的关键类是:org.apache.ibatis.builder.annotation.MapperAnnotationBuilder,里面有一个方法</p><p>parse():用来解析dao的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取所有dao接口的全限定类名</span></span><br><span class="line">   String resource = type.toString();</span><br><span class="line">   <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">     <span class="comment">//解析xml配置文件</span></span><br><span class="line">     loadXmlResource();</span><br><span class="line">     configuration.addLoadedResource(resource);</span><br><span class="line">     assistant.setCurrentNamespace(type.getName());</span><br><span class="line">     parseCache();</span><br><span class="line">     parseCacheRef();</span><br><span class="line">     Method[] methods = type.getMethods();</span><br><span class="line">     <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// issue #237</span></span><br><span class="line">         <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">           <span class="comment">//解析出方法注解上面的statement语句</span></span><br><span class="line">           parseStatement(method);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">         configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   parsePendingMethods();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="由此可见-在解析annotation的之前-已经有个loadXmlResource-方法去解析xml的mapper文件-也就是如果xml存在-后面解析annotation得到的sql会将其覆盖"><a href="#由此可见-在解析annotation的之前-已经有个loadXmlResource-方法去解析xml的mapper文件-也就是如果xml存在-后面解析annotation得到的sql会将其覆盖" class="headerlink" title="由此可见,在解析annotation的之前,已经有个loadXmlResource();方法去解析xml的mapper文件,也就是如果xml存在,后面解析annotation得到的sql会将其覆盖."></a>由此可见,在解析annotation的之前,已经有个loadXmlResource();方法去解析xml的mapper文件,也就是如果xml存在,后面解析annotation得到的sql会将其覆盖.</h3><h3 id="二-使用annotation时没有xml为什么不会报错"><a href="#二-使用annotation时没有xml为什么不会报错" class="headerlink" title="二.使用annotation时没有xml为什么不会报错?"></a>二.使用annotation时没有xml为什么不会报错?</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadXmlResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Spring may not know the real resource name so we check a flag</span></span><br><span class="line">  <span class="comment">// to prevent loading again a resource twice</span></span><br><span class="line">  <span class="comment">// this flag is set at XMLMapperBuilder#bindMapperForNamespace</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(<span class="string">"namespace:"</span> + type.getName())) &#123;</span><br><span class="line">    <span class="comment">//获取当前&lt;mapper/&gt;标签下面扫描包的xml映射文件</span></span><br><span class="line">    String xmlResource = type.getName().replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".xml"</span>;</span><br><span class="line">    <span class="comment">// #1347</span></span><br><span class="line">    InputStream inputStream = type.getResourceAsStream(<span class="string">"/"</span> + xmlResource);</span><br><span class="line">    <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Search XML mapper that is not in the module but in the classpath.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果不在接口的包下面,则去找classpath下面的xml文件</span></span><br><span class="line">        inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">        <span class="comment">// ignore, resource is not required</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到的话就去解析对应的sql语句</span></span><br><span class="line">    <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">      XMLMapperBuilder xmlParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());</span><br><span class="line">      xmlParser.parse();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这里没有报错的原因是-当xml文件不存在的时候-Resources-getResourceAsStream的方法抛出的异常被catch捕获到并且没有作任何处理-所以没有报错"><a href="#这里没有报错的原因是-当xml文件不存在的时候-Resources-getResourceAsStream的方法抛出的异常被catch捕获到并且没有作任何处理-所以没有报错" class="headerlink" title="这里没有报错的原因是,当xml文件不存在的时候,Resources.getResourceAsStream的方法抛出的异常被catch捕获到并且没有作任何处理,所以没有报错"></a>这里没有报错的原因是,当xml文件不存在的时候,Resources.getResourceAsStream的方法抛出的异常被catch捕获到并且没有作任何处理,所以没有报错</h3><h3 id="三-接着上面的那个方法来说明一个坑"><a href="#三-接着上面的那个方法来说明一个坑" class="headerlink" title="三.接着上面的那个方法来说明一个坑:"></a>三.接着上面的那个方法来说明一个坑:</h3><h3 id="当mybatis主配置文件使用如下方式来指定mapper文件位置时"><a href="#当mybatis主配置文件使用如下方式来指定mapper文件位置时" class="headerlink" title="当mybatis主配置文件使用如下方式来指定mapper文件位置时:"></a>当mybatis主配置文件使用如下方式来指定mapper文件位置时:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.pan.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="会出现一个严重的错误-无论你的mapper文件是放在同包下面-并且没有路径出错的问题时-mybatis依然会报错说没有绑定对应的sql语句-原因是使用maven建立mybatis项目时-maven工程会忽略掉src-main-java下面的所有资源-然后可以利用上面的loadXmlResource-方法进行解释出错的原因"><a href="#会出现一个严重的错误-无论你的mapper文件是放在同包下面-并且没有路径出错的问题时-mybatis依然会报错说没有绑定对应的sql语句-原因是使用maven建立mybatis项目时-maven工程会忽略掉src-main-java下面的所有资源-然后可以利用上面的loadXmlResource-方法进行解释出错的原因" class="headerlink" title="会出现一个严重的错误:无论你的mapper文件是放在同包下面,并且没有路径出错的问题时,mybatis依然会报错说没有绑定对应的sql语句,原因是使用maven建立mybatis项目时,maven工程会忽略掉src/main/java下面的所有资源,然后可以利用上面的loadXmlResource()方法进行解释出错的原因."></a>会出现一个严重的错误:无论你的mapper文件是放在同包下面,并且没有路径出错的问题时,mybatis依然会报错说没有绑定对应的sql语句,原因是使用maven建立mybatis项目时,maven工程会忽略掉<strong>src/main/java</strong>下面的所有资源,然后可以利用上面的loadXmlResource()方法进行解释出错的原因.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadXmlResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Spring may not know the real resource name so we check a flag</span></span><br><span class="line">  <span class="comment">// to prevent loading again a resource twice</span></span><br><span class="line">  <span class="comment">// this flag is set at XMLMapperBuilder#bindMapperForNamespace</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(<span class="string">"namespace:"</span> + type.getName())) &#123;</span><br><span class="line">    <span class="comment">//程序来到这里时,会获取该包下面的xml文件的名称</span></span><br><span class="line">    String xmlResource = type.getName().replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".xml"</span>;</span><br><span class="line">    <span class="comment">// #1347</span></span><br><span class="line">    <span class="comment">//2.但是来到这里发现文件是不存在的,由于maven的原因</span></span><br><span class="line">    InputStream inputStream = type.getResourceAsStream(<span class="string">"/"</span> + xmlResource);</span><br><span class="line">    <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Search XML mapper that is not in the module but in the classpath.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果不在接口的包下面,则去找classpath下面的xml文件</span></span><br><span class="line">        <span class="comment">//3.又来到classpath路径下找相同名称的xml文件,发现还是没有</span></span><br><span class="line">        inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">        <span class="comment">// ignore, resource is not required</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到的话就去解析对应的sql语句</span></span><br><span class="line">    <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">      XMLMapperBuilder xmlParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());</span><br><span class="line">      xmlParser.parse();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//4.没有解析xml文件,sql都没有解析,方法就完成了,也就是没有进行sql的绑定.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原因-没有解析xml文件-sql都没有解析-方法就完成了-也就是没有进行sql的绑定"><a href="#原因-没有解析xml文件-sql都没有解析-方法就完成了-也就是没有进行sql的绑定" class="headerlink" title="原因:没有解析xml文件,sql都没有解析,方法就完成了,也就是没有进行sql的绑定."></a>原因:没有解析xml文件,sql都没有解析,方法就完成了,也就是没有进行sql的绑定.</h3><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果不添加这个src/main/resources文件夹将消失,但没关系,看个人需要 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四-解析-完的xml主配置文件到哪里去了"><a href="#四-解析-完的xml主配置文件到哪里去了" class="headerlink" title="四.解析 完的xml主配置文件到哪里去了?"></a>四.解析 完的xml主配置文件到哪里去了?</h3><h3 id="在mybatis中有一个类用于存放主配置信息-org-apache-ibatis-session-Configuration-在主配置文件解析完以后-就会将信息存放到该对象中-成员变量就是标签对应的属性"><a href="#在mybatis中有一个类用于存放主配置信息-org-apache-ibatis-session-Configuration-在主配置文件解析完以后-就会将信息存放到该对象中-成员变量就是标签对应的属性" class="headerlink" title="在mybatis中有一个类用于存放主配置信息:org.apache.ibatis.session.Configuration,在主配置文件解析完以后,就会将信息存放到该对象中,成员变量就是标签对应的属性."></a>在mybatis中有一个类用于存放主配置信息:org.apache.ibatis.session.Configuration,在主配置文件解析完以后,就会将信息存放到该对象中,成员变量就是标签对应的属性.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Environment environment;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> safeRowBoundsEnabled;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> safeResultHandlerEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> mapUnderscoreToCamelCase;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> aggressiveLazyLoading;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> multipleResultSetsEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> useGeneratedKeys;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> useColumnLabel = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> cacheEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> callSettersOnNulls;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> useActualParamName = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> returnInstanceForEmptyRow;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> String logPrefix;</span><br><span class="line">  <span class="keyword">protected</span> Class&lt;? extends Log&gt; logImpl;</span><br><span class="line">  <span class="keyword">protected</span> Class&lt;? extends VFS&gt; vfsImpl;</span><br><span class="line">  <span class="keyword">protected</span> LocalCacheScope localCacheScope = LocalCacheScope.SESSION;</span><br><span class="line">  <span class="keyword">protected</span> JdbcType jdbcTypeForNull = JdbcType.OTHER;</span><br><span class="line">  <span class="keyword">protected</span> Set&lt;String&gt; lazyLoadTriggerMethods = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"equals"</span>, <span class="string">"clone"</span>, <span class="string">"hashCode"</span>, <span class="string">"toString"</span>));</span><br><span class="line">  <span class="keyword">protected</span> Integer defaultStatementTimeout;</span><br><span class="line">  <span class="keyword">protected</span> Integer defaultFetchSize;</span><br><span class="line">  <span class="keyword">protected</span> ResultSetType defaultResultSetType;</span><br><span class="line">  <span class="keyword">protected</span> ExecutorType defaultExecutorType = ExecutorType.SIMPLE;</span><br><span class="line">  <span class="keyword">protected</span> AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;</span><br><span class="line">  <span class="keyword">protected</span> AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Properties variables = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="keyword">protected</span> ReflectorFactory reflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br><span class="line">  <span class="keyword">protected</span> ObjectFactory objectFactory = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line">  <span class="keyword">protected</span> ObjectWrapperFactory objectWrapperFactory = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> lazyLoadingEnabled = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">protected</span> ProxyFactory proxyFactory = <span class="keyword">new</span> JavassistProxyFactory(); <span class="comment">// #224 Using internal Javassist instead of OGNL</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> String databaseId;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Configuration factory class.</span></span><br><span class="line"><span class="comment">   * Used to create Configuration for loading deserialized unread properties.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> &lt;a href='https://code.google.com/p/mybatis/issues/detail?id=300'&gt;Issue 300 (google code)&lt;/a&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; configurationFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry = <span class="keyword">new</span> TypeHandlerRegistry();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry = <span class="keyword">new</span> TypeAliasRegistry();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> LanguageDriverRegistry languageRegistry = <span class="keyword">new</span> LanguageDriverRegistry();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">"Mapped Statements collection"</span>)</span><br><span class="line">      .conflictMessageProducer((savedValue, targetValue) -&gt;</span><br><span class="line">          <span class="string">". please check "</span> + savedValue.getResource() + <span class="string">" and "</span> + targetValue.getResource());</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Cache&gt; caches = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"Caches collection"</span>);</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"Result Maps collection"</span>);</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ParameterMap&gt; parameterMaps = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"Parameter Maps collection"</span>);</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, KeyGenerator&gt; keyGenerators = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"Key Generators collection"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Set&lt;String&gt; loadedResources = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, XNode&gt; sqlFragments = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"XML fragments parsed from previous mappers"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;XMLStatementBuilder&gt; incompleteStatements = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;CacheRefResolver&gt; incompleteCacheRefs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;ResultMapResolver&gt; incompleteResultMaps = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;MethodResolver&gt; incompleteMethods = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五-自定义的typeHandle-类型处理器"><a href="#五-自定义的typeHandle-类型处理器" class="headerlink" title="五.自定义的typeHandle(类型处理器)"></a>五.自定义的typeHandle(类型处理器)</h3><p>官方对typeHandle的定义:</p><blockquote><p>Whenever MyBatis sets a parameter on a PreparedStatement or retrieves a value from a ResultSet, a TypeHandler is used to retrieve the value in a means appropriate to the Java type. The following table describes the default TypeHandlers.</p></blockquote><p>自定义typeHandle的实现:</p><blockquote><p>You can override the type handlers or create your own to deal with unsupported or non-standard types. To do so, implement the interface <code>org.apache.ibatis.type.TypeHandler</code> or extend the convenience class <code>org.apache.ibatis.type.BaseTypeHandler</code> and optionally map it to a JDBC type. </p></blockquote><h3 id="继承BaseTypeHandler"><a href="#继承BaseTypeHandler" class="headerlink" title="继承BaseTypeHandler:"></a>继承BaseTypeHandler<t>:</t></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExampleTypeHandler.java</span></span><br><span class="line"><span class="meta">@MappedJdbcTypes</span>(JdbcType.VARCHAR)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">    String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ps.setString(i, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主配置文件中"><a href="#主配置文件中" class="headerlink" title="主配置文件中:"></a>主配置文件中:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入自定义的typeHandle--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com.pan.handler.MyHandler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="同时也可以在resultMap中使用"><a href="#同时也可以在resultMap中使用" class="headerlink" title="同时也可以在resultMap中使用:"></a>同时也可以在resultMap中使用:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Country"</span> <span class="attr">id</span>=<span class="string">"countryMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cid"</span> <span class="attr">property</span>=<span class="string">"cid"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果这里标签里面加入了jdbcType的话,MyHandle里面的@MappedJdbcTypes中的配置jdbc类型则忽略--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cname"</span> <span class="attr">property</span>=<span class="string">"cname"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">typeHandler</span>=<span class="string">"com.pan.handler.MyHandler"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 与上面的作用一样</span></span><br><span class="line"><span class="comment">&lt;result column="cname" property="cname"  typeHandler="com.pan.handler.MyHandler"/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--property中放关联属性  ofType指封装的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"ministers"</span> <span class="attr">ofType</span>=<span class="string">"Minister"</span> <span class="attr">select</span>=<span class="string">"selectMinisterByCountry"</span> <span class="attr">column</span>=<span class="string">"cid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在与spring整合时使用的sqlSessionFactory是org-mybatis-spring-SqlSessionFactoryBean，此时要注册自定义的TypeHandler，只需要把自定义的handler往这个bean里面丢（setTypeHandlers-setTypeHandlersPackage-）"><a href="#在与spring整合时使用的sqlSessionFactory是org-mybatis-spring-SqlSessionFactoryBean，此时要注册自定义的TypeHandler，只需要把自定义的handler往这个bean里面丢（setTypeHandlers-setTypeHandlersPackage-）" class="headerlink" title="在与spring整合时使用的sqlSessionFactory是org.mybatis.spring.SqlSessionFactoryBean，此时要注册自定义的TypeHandler，只需要把自定义的handler往这个bean里面丢（setTypeHandlers()/setTypeHandlersPackage()）"></a>在与spring整合时使用的sqlSessionFactory是org.mybatis.spring.SqlSessionFactoryBean，此时要注册自定义的TypeHandler，只需要把自定义的handler往这个bean里面丢（setTypeHandlers()/setTypeHandlersPackage()）</h3><h3 id="六-自定义插件-plugins"><a href="#六-自定义插件-plugins" class="headerlink" title="六.自定义插件(plugins):"></a>六.自定义插件(plugins):</h3><p>MyBatis allows you to intercept calls to at certain points within the execution of a mapped statement. By default, MyBatis allows plug-ins to intercept method calls of:</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><h3 id="How-to-do"><a href="#How-to-do" class="headerlink" title="How to do?"></a>How to do?</h3><p>Using plug-ins is pretty simple given the power they provide. Simply implement the Interceptor interface, being sure to specify the signatures you want to intercept.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExamplePlugin.java</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">  type= Executor.class,</span><br><span class="line">  method = <span class="string">"update"</span>,</span><br><span class="line">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// implement pre processing if need</span></span><br><span class="line">    Object returnObject = invocation.proceed();</span><br><span class="line">    <span class="comment">// implement post processing if need</span></span><br><span class="line">    <span class="keyword">return</span> returnObject;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.properties = properties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"org.mybatis.example.ExamplePlugin"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>The plug-in above will intercept all calls to the “update” method on the Executor instance, which is an internal object responsible for the low level execution of mapped statements.</p><p>第二种方法:</p><p>除了用插件来修改 MyBatis 核心行为之外，还可以通过完全覆盖配置类来达到目的。只需继承后覆盖其中的每个方法，再把它传递到 SqlSessionFactoryBuilder.build(myConfig) 方法即可。再次重申，这可能会严重影响 MyBatis 的行为，务请慎之又慎。</p><h2 id="七-在关联查询里是怎么实现执行第二句select语句的"><a href="#七-在关联查询里是怎么实现执行第二句select语句的" class="headerlink" title="七.在关联查询里是怎么实现执行第二句select语句的"></a>七.在关联查询里是怎么实现执行第二句select语句的</h2><p>在使用了关联查询之后，会有这么一个问题，我们调用的mapper方法只是查询第一条select语句，其关联部分的select语句到底是怎么执行的？为什么会执行？什么时候执行？</p><p>下面直接使用源码解释上面的问题，注意：为了使演示明显，我们开启了lazyload，关于lazyload的信息也在上面的地址有<br>在mybatis里有这么一个类org.apache.ibatis.executor.resultset.DefaultResultSetHandler，我们来关注里面这么一个方法 <strong>getPropertyMappingValue()</strong> nested：嵌套<br>在看getPropertyMappingValue()方法的源代码之前，我们有必要先模拟出一个mapper文件里的resultMap，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Country"</span> <span class="attr">id</span>=<span class="string">"countryMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cid"</span> <span class="attr">property</span>=<span class="string">"cid"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果这里标签里面加入了jdbcType的话,MyHandle里面的@MappedJdbcTypes中的配置jdbc类型则忽略--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cname"</span> <span class="attr">property</span>=<span class="string">"cname"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">typeHandler</span>=<span class="string">"com.pan.handler.MyHandler"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 与上面的作用一样</span></span><br><span class="line"><span class="comment">&lt;result column="cname" property="cname"  typeHandler="com.pan.handler.MyHandler"/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--property中放关联属性  ofType指封装的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"ministers"</span> <span class="attr">ofType</span>=<span class="string">"Minister"</span> <span class="attr">select</span>=<span class="string">"selectMinisterByCountry"</span> <span class="attr">column</span>=<span class="string">"cid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是我们getPropertyMappingValue()方法的源代码。我们将模拟运行情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getPropertyMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//判断是否存在嵌套查询ID（说白了就是判断上面resultMap的子标签里是否存在select="selectParentById"）</span></span><br><span class="line"><span class="keyword">if</span> (propertyMapping.getNestedQueryId() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//存在嵌套查询id：namespace.selectParentById</span></span><br><span class="line"><span class="comment">//当然，id，name并不存在nestedQueryId，只有到了parent才会进来这个方法</span></span><br><span class="line"><span class="comment">//我们来看看这个方法的实现，该代码框里下方的代码暂时不重要了，看下一个代码块</span></span><br><span class="line"><span class="keyword">return</span> getNestedQueryMappingValue(rs, metaResultObject, propertyMapping, lazyLoader, columnPrefix);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMapping.getResultSet() != <span class="keyword">null</span>) &#123;</span><br><span class="line">addPendingChildRelation(rs, metaResultObject, propertyMapping);   <span class="comment">// TODO is that OK?</span></span><br><span class="line"><span class="keyword">return</span> DEFERRED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = propertyMapping.getTypeHandler();</span><br><span class="line"><span class="keyword">final</span> String column = prependPrefix(propertyMapping.getColumn(), columnPrefix);</span><br><span class="line"><span class="keyword">return</span> typeHandler.getResult(rs, column);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getNestedQueryMappingValue</span><span class="params">(ResultSet rs, MetaObject metaResultObject, ResultMapping propertyMapping, ResultLoaderMap lazyLoader, String columnPrefix)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...这些代码就省略了，暂时不重要</span><br><span class="line"><span class="keyword">if</span> (propertyMapping.isLazy()) &#123;</span><br><span class="line"><span class="comment">//重要的是这一句！！</span></span><br><span class="line"><span class="comment">//往lazyLoader(ResultLoaderMap)里丢loader，包含了关联加载的各种信息</span></span><br><span class="line">lazyLoader.addLoader(property, metaResultObject, resultLoader);</span><br><span class="line">value = DEFERRED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">value = resultLoader.loadResult();</span><br><span class="line">&#125;</span><br><span class="line">...这些代码就省略了，暂时不重要</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里我们可以推断出，mybatis关联查询的lazyload的是通过一个lazyLoader(Map)来实现的。大概流程如下，查询了第一个select语句后，把关联查询的语句暂时保存在一个map中。在真正需要的时候再来调用（这里默认将的是深度延迟加载，具体看上面的链接）。<br>接下来我们来验证上面的说法，思路很简单，既然mybatis向map中addLoader，那么在真正使用的时候肯定会取出来。所以我们来到这个map的实现类ResultLoaderMap来看一下他的方法 <img src="http://irats.cn:8888/group1/M00/00/00/rBECIl1xPYKAYm5OAABOodmXHrU792.png" alt="1"> </p><h3 id="分析如何执行延时加载的select语句"><a href="#分析如何执行延时加载的select语句" class="headerlink" title="分析如何执行延时加载的select语句:"></a>分析如何执行延时加载的select语句:</h3><h3 id="当调用关联对象的get-方法时-会调用org-apache-ibatis-executor-loader-javassist-JavassistProxyFactory的invoke方法"><a href="#当调用关联对象的get-方法时-会调用org-apache-ibatis-executor-loader-javassist-JavassistProxyFactory的invoke方法" class="headerlink" title="当调用关联对象的get()方法时,会调用org.apache.ibatis.executor.loader.javassist.JavassistProxyFactory的invoke方法:"></a>当调用关联对象的get()方法时,会调用org.apache.ibatis.executor.loader.javassist.JavassistProxyFactory的invoke方法:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object enhanced, Method method, Method methodProxy, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lazyLoader) &#123;</span><br><span class="line">          <span class="keyword">if</span> (WRITE_REPLACE_METHOD.equals(methodName)) &#123;</span><br><span class="line">            Object original;</span><br><span class="line">            <span class="keyword">if</span> (constructorArgTypes.isEmpty()) &#123;</span><br><span class="line">              original = objectFactory.create(type);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              original = objectFactory.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">            &#125;</span><br><span class="line">            PropertyCopier.copyBeanProperties(type, enhanced, original);</span><br><span class="line">            <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> JavassistSerialStateHolder(original, lazyLoader.getProperties(), objectFactory, constructorArgTypes, constructorArgs);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> original;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//lazyLoader是一个ResultLoaderMap</span></span><br><span class="line">            <span class="comment">//这里判断map中是否存在键值对</span></span><br><span class="line">            <span class="keyword">if</span> (lazyLoader.size() &gt; <span class="number">0</span> &amp;&amp; !FINALIZE_METHOD.equals(methodName)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (aggressive || lazyLoadTriggerMethods.contains(methodName)) &#123;</span><br><span class="line">                <span class="comment">//到这里进行所有的map里面的键值对的load方法</span></span><br><span class="line">                lazyLoader.loadAll();</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isSetter(methodName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                lazyLoader.remove(property);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PropertyNamer.isGetter(methodName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String property = PropertyNamer.methodToProperty(methodName);</span><br><span class="line">                <span class="keyword">if</span> (lazyLoader.hasLoader(property)) &#123;</span><br><span class="line">                  lazyLoader.load(property);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invoke(enhanced, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="loadAll"><a href="#loadAll" class="headerlink" title="loadAll():"></a>loadAll():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadAll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; methodNameSet = loaderMap.keySet();</span><br><span class="line">    String[] methodNames = methodNameSet.toArray(<span class="keyword">new</span> String[methodNameSet.size()]);</span><br><span class="line">    <span class="keyword">for</span> (String methodName : methodNames) &#123;</span><br><span class="line">      load(methodName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">(String property)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  LoadPair pair = loaderMap.remove(property.toUpperCase(Locale.ENGLISH));</span><br><span class="line">  <span class="keyword">if</span> (pair != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">//上面从map移除key，拿这里应该就是进行查询了，跟进去看看</span></span><br><span class="line">    pair.load();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个方法调用，继续跟进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.load(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>进来后这个方法的底部有这么一句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有setValue还有loadResult()</span></span><br><span class="line"><span class="comment">//你懂的，进去进去</span></span><br><span class="line"><span class="keyword">this</span>.metaResultObject.setValue(property, <span class="keyword">this</span>.resultLoader.loadResult());</span><br></pre></td></tr></table></figure><p>进来loadResult()方法，代码如下：selectList()，讲道理到这里就可以完了，但是还是进去瞅下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">loadResult</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;Object&gt; list = selectList();</span><br><span class="line">  resultObject = resultExtractor.extractObjectFromList(list, targetType);</span><br><span class="line">  <span class="keyword">return</span> resultObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入selectList()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Executor localExecutor = executor;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread().getId() != <span class="keyword">this</span>.creatorThreadId || localExecutor.isClosed()) &#123;</span><br><span class="line">    localExecutor = newExecutor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">//return + query方法，到了这里就不再继续跟进了，已经够了</span></span><br><span class="line">    <span class="keyword">return</span> localExecutor.&lt;E&gt; query(mappedStatement, parameterObject, RowBounds.DEFAULT, Executor.NO_RESULT_HANDLER, cacheKey, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (localExecutor != executor) &#123;</span><br><span class="line">      localExecutor.close(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从selectList()方法出来后就执行setValue方法，剩下的就不说了。这里主要是讲lazyload是如何实现的，到这里就已经完了。其他的以后再说</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-xml和annotation同时使用哪个会生效&quot;&gt;&lt;a href=&quot;#一-xml和annotation同时使用哪个会生效&quot; class=&quot;headerlink&quot; title=&quot;一.xml和annotation同时使用哪个会生效&quot;&gt;&lt;/a&gt;一.xml和annot
      
    
    </summary>
    
    
      <category term="ssm" scheme="http://Homeofpan.github.io/categories/ssm/"/>
    
    
      <category term="mybatis" scheme="http://Homeofpan.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis重点复习</title>
    <link href="http://Homeofpan.github.io/2019/10/15/mybatis%E9%87%8D%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    <id>http://Homeofpan.github.io/2019/10/15/mybatis重点复习/</id>
    <published>2019-10-15T06:08:55.000Z</published>
    <updated>2019-10-15T10:57:35.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mybatis用到的动态代理设计模式"><a href="#Mybatis用到的动态代理设计模式" class="headerlink" title="Mybatis用到的动态代理设计模式:"></a>Mybatis用到的动态代理设计模式:</h3><h3 id="作用-用于增强目标对象的目标方法"><a href="#作用-用于增强目标对象的目标方法" class="headerlink" title="作用:用于增强目标对象的目标方法"></a>作用:用于增强目标对象的目标方法</h3><blockquote><h3 id="1-静态代理模式-在程序没有运行时-已经提前增强了-例如-你一直都有请一个律师顾问-平时一直都为你工作-不仅仅是只替你有官司的时候再来工作"><a href="#1-静态代理模式-在程序没有运行时-已经提前增强了-例如-你一直都有请一个律师顾问-平时一直都为你工作-不仅仅是只替你有官司的时候再来工作" class="headerlink" title="1.静态代理模式:在程序没有运行时,已经提前增强了.例如:你一直都有请一个律师顾问,平时一直都为你工作,不仅仅是只替你有官司的时候再来工作"></a>1.静态代理模式:在程序没有运行时,已经提前增强了.例如:你一直都有请一个律师顾问,平时一直都为你工作,不仅仅是只替你有官司的时候再来工作</h3><h3 id="2-动态代理-jdk-有接口使用-和cglib-无接口使用-不建议使用-会污染代码"><a href="#2-动态代理-jdk-有接口使用-和cglib-无接口使用-不建议使用-会污染代码" class="headerlink" title="2.动态代理(jdk(有接口使用)和cglib(无接口使用,不建议使用,会污染代码))"></a>2.动态代理(jdk(有接口使用)和cglib(无接口使用,不建议使用,会污染代码))</h3><h3 id="在程序没有运行之前-是不会对你的目标方法进行增强-当你需要增强目标方法的时候-才会帮你增强-例如-平时你没有官司打-某一天-很不幸被人xxx-要打官司了-这个时候你去请你律师帮你打"><a href="#在程序没有运行之前-是不会对你的目标方法进行增强-当你需要增强目标方法的时候-才会帮你增强-例如-平时你没有官司打-某一天-很不幸被人xxx-要打官司了-这个时候你去请你律师帮你打" class="headerlink" title=":在程序没有运行之前,是不会对你的目标方法进行增强,当你需要增强目标方法的时候,才会帮你增强;例如:平时你没有官司打,某一天,很不幸被人xxx,要打官司了,这个时候你去请你律师帮你打."></a>:在程序没有运行之前,是不会对你的目标方法进行增强,当你需要增强目标方法的时候,才会帮你增强;例如:平时你没有官司打,某一天,很不幸被人xxx,要打官司了,这个时候你去请你律师帮你打.</h3></blockquote><h3 id="一-Mybatis的动态代理"><a href="#一-Mybatis的动态代理" class="headerlink" title="一.Mybatis的动态代理:"></a>一.Mybatis的动态代理:</h3><p>注意点</p><h3 id="1-mapper映射文件中的namespace一定为-dao层接口的全限定类名"><a href="#1-mapper映射文件中的namespace一定为-dao层接口的全限定类名" class="headerlink" title="1.mapper映射文件中的namespace一定为:dao层接口的全限定类名"></a>1.mapper映射文件中的namespace一定为:dao层接口的全限定类名</h3><h3 id="2-mapper中的对应sql语句的id一定要与接口的方法名字一致-否则会报一下错误"><a href="#2-mapper中的对应sql语句的id一定要与接口的方法名字一致-否则会报一下错误" class="headerlink" title="2.mapper中的对应sql语句的id一定要与接口的方法名字一致,否则会报一下错误:"></a>2.mapper中的对应sql语句的id一定要与接口的方法名字一致,否则会报一下错误:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.binding.BindingException: <span class="function">Invalid bound <span class="title">statement</span> <span class="params">(not found)</span>:</span></span><br></pre></td></tr></table></figure><h3 id="二-传入动态代理的参数为map时"><a href="#二-传入动态代理的参数为map时" class="headerlink" title="二.传入动态代理的参数为map时:"></a>二.传入动态代理的参数为map时:</h3><p>由于无法将传过来的数据包装成一个对象,有String,Integer,Student这三个参数.当用于多条件查询的时候,就可以使用map参数的传递:</p><p>dao:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStudentDao</span> </span>&#123;</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectStudentByCondition</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper:</p><h3 id="接收的参数格式为-map按顺序放进去的key的值"><a href="#接收的参数格式为-map按顺序放进去的key的值" class="headerlink" title="接收的参数格式为:#{map按顺序放进去的key的值}"></a>接收的参数格式为:#{map按顺序放进去的key的值}</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.pan.dao.IStudentDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectStudentByCondition"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">select id,name,age,score from student1</span><br><span class="line"> where name like '%' #&#123;nameCon&#125; '%' </span><br><span class="line"> and age &gt; #&#123;ageCon&#125;</span><br><span class="line"> and score &gt; #&#123;stu.score&#125;</span><br><span class="line"><span class="comment">&lt;!-- select id,name,age,score from student1 where name like '%$&#123;value&#125;%' --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>test:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"田七"</span>,<span class="number">27</span>,<span class="number">90</span>);</span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">map.put(<span class="string">"nameCon"</span>,<span class="string">"张"</span>);</span><br><span class="line">map.put(<span class="string">"ageCon"</span>, <span class="number">23</span>);</span><br><span class="line">map.put(<span class="string">"stu"</span>,stu);</span><br><span class="line">List&lt;Student&gt; students = dao.selectStudentByCondition(map);</span><br><span class="line"><span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">System.out.println(student);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种动态代理获取参数的方法"><a href="#第二种动态代理获取参数的方法" class="headerlink" title="第二种动态代理获取参数的方法:"></a>第二种动态代理获取参数的方法:</h3><p>mapper2:</p><h3 id="接收格式-arg-map中索引的值"><a href="#接收格式-arg-map中索引的值" class="headerlink" title="接收格式:#{arg+map中索引的值}"></a>接收格式:#{arg+map中索引的值}</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.pan.dao.IStudentDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectStudentByCondition"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">select id,name,age,score from student1</span><br><span class="line"> where name like '%' #&#123;arg0&#125; '%' </span><br><span class="line"> and age &gt; #&#123;arg1&#125;</span><br><span class="line"><span class="comment">&lt;!-- select id,name,age,score from student1 where name like '%$&#123;value&#125;%' --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><blockquote><h3 id="Mapper映射文件中的sql语句的-可以放的内容"><a href="#Mapper映射文件中的sql语句的-可以放的内容" class="headerlink" title="Mapper映射文件中的sql语句的#{}可以放的内容:"></a>Mapper映射文件中的sql语句的#{}可以放的内容:</h3><ol><li><h3 id="参数对象的属性"><a href="#参数对象的属性" class="headerlink" title="参数对象的属性"></a>参数对象的属性</h3></li><li><h3 id="随意内容-作为占位符"><a href="#随意内容-作为占位符" class="headerlink" title="随意内容,作为占位符"></a>随意内容,作为占位符</h3></li><li><h3 id="参数为map时的key"><a href="#参数为map时的key" class="headerlink" title="参数为map时的key"></a>参数为map时的key</h3></li><li><h3 id="参数为map时-若key的value为对象-则可将该对象的属性放入"><a href="#参数为map时-若key的value为对象-则可将该对象的属性放入" class="headerlink" title="参数为map时,若key的value为对象,则可将该对象的属性放入"></a>参数为map时,若key的value为对象,则可将该对象的属性放入</h3></li><li><h3 id="参数的索引号"><a href="#参数的索引号" class="headerlink" title="参数的索引号"></a>参数的索引号</h3></li></ol></blockquote><h3 id="三-多表关联查询对返回对象的封装"><a href="#三-多表关联查询对返回对象的封装" class="headerlink" title="三.多表关联查询对返回对象的封装:"></a>三.多表关联查询对返回对象的封装:</h3><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种:"></a>第一种:</h3><p>pojo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer cid;</span><br><span class="line"><span class="keyword">private</span> String cname;</span><br><span class="line"><span class="comment">//关联属性</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Minister&gt; ministers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getCid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.pan.dao.ICountryDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Country"</span> <span class="attr">id</span>=<span class="string">"countryMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cid"</span> <span class="attr">property</span>=<span class="string">"cid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cname"</span> <span class="attr">property</span>=<span class="string">"cname"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--property中放关联属性  ofType指封装的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"ministers"</span> <span class="attr">ofType</span>=<span class="string">"Minister"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"mid"</span> <span class="attr">property</span>=<span class="string">"mid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"mname"</span> <span class="attr">property</span>=<span class="string">"mname"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectCountryById"</span> <span class="attr">resultMap</span>=<span class="string">"countryMap"</span>&gt;</span></span><br><span class="line">select cid,cname,mid,mname </span><br><span class="line">from country,minister </span><br><span class="line">where countryid=cid and cid=#&#123;xxx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="第二种-使用递归查询的方式"><a href="#第二种-使用递归查询的方式" class="headerlink" title="第二种:(使用递归查询的方式)"></a>第二种:(使用递归查询的方式)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.pan.dao.ICountryDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectMinisterByCountry"</span> <span class="attr">resultType</span>=<span class="string">"Minister"</span>&gt;</span></span><br><span class="line">select mid,mname from minister where countryid =#&#123;ooo&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Country"</span> <span class="attr">id</span>=<span class="string">"countryMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cid"</span> <span class="attr">property</span>=<span class="string">"cid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cname"</span> <span class="attr">property</span>=<span class="string">"cname"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--property中放关联属性  ofType指封装的类型--&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--column:里面的参数是传入给select语句所使用的参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"ministers"</span> <span class="attr">ofType</span>=<span class="string">"Minister"</span> <span class="attr">select</span>=<span class="string">"selectMinisterByCountry"</span> <span class="attr">column</span>=<span class="string">"cid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectCountryById"</span> <span class="attr">resultMap</span>=<span class="string">"countryMap"</span>&gt;</span></span><br><span class="line">select cid,cname from country where cid=#&#123;xx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四-延时加载"><a href="#四-延时加载" class="headerlink" title="四:延时加载:"></a>四:延时加载:</h3><p>MyBatis中的延时加载，也称为懒加载，是指在进行关联查询时（也就是上面的多表查询），按照设置延时规则推迟对关联对象的select查询。延时加载可以有效的较少数据库压力。</p><p>需要置疑的是，MyBatis的延迟加载只是对关联对象的查询有延迟设置，对于主加载的对象都是直接执行查询语句的。下面是关联查询的mapper语句（其实就在上面）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.pan.dao.ICountryDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"Country"</span> <span class="attr">id</span>=<span class="string">"countryMap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"cid"</span> <span class="attr">property</span>=<span class="string">"cid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"cname"</span> <span class="attr">property</span>=<span class="string">"cname"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--property中放关联属性  ofType指封装的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"ministers"</span> <span class="attr">ofType</span>=<span class="string">"Minister"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"mid"</span> <span class="attr">property</span>=<span class="string">"mid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"mname"</span> <span class="attr">property</span>=<span class="string">"mname"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectCountryById"</span> <span class="attr">resultMap</span>=<span class="string">"countryMap"</span>&gt;</span></span><br><span class="line">select cid,cname,mid,mname </span><br><span class="line">from country,minister </span><br><span class="line">where countryid=cid and cid=#&#123;xxx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2关联对象的加载时机"><a href="#4-2关联对象的加载时机" class="headerlink" title="4.2关联对象的加载时机:"></a>4.2关联对象的加载时机:</h3><p>mybatis的延时加载分三种类型：直接加载，侵入式延迟加载，深度延迟加载</p><ul><li>直接加载 执行完对主加载对象的select语句，马上执行对关联对象的select查询</li><li>侵入式延迟 执行对主加载对象的查询时，不会执行对关联对象的查询。担当要访问主加载对象的详情时，就会马上执行关联对象的select查询。即对关联对象的查询执行，侵入到了主加载对象的详情访问中。</li><li>深度延迟 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的select查询。只有当真正的访问关联对象的时候，才会执行对关联对象的select查询</li></ul><h3 id="开启延时加载的配置"><a href="#开启延时加载的配置" class="headerlink" title="开启延时加载的配置:"></a>开启延时加载的配置:</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--延迟加载的总开关  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--侵入式加载的总开关,默认为false,意味着是深度延迟,前提是延时加载开启了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="五-查询缓存"><a href="#五-查询缓存" class="headerlink" title="五.查询缓存:"></a>五.查询缓存:</h3><p>myabtis的查询缓存机制，根据缓存区的作用域与生命周期，可划分为两种：一级缓存、二级缓存<br>mybatis查询缓存的作用域是根据映射文件mapper的namespace划分的，相同的namespace的mapper查询数据库存在同一个缓存区域。不同namespace下的数据互不干扰。无论是一级缓存还是二级缓存，都是按照namespace进行分别存放的。<br>但一、二级缓存的不同之处在于，以及一级缓存的作用域是:SqlSession,SqlSession一旦关闭，则SqlSession中的数据将不存在，即一级缓存就不复存在。而二级缓存的生命周期会与整个应用同步，与SqlSession是否关闭没有关系。换句话 <strong>一级缓存是在同一线程（同一SqlSession）间共享数据，而二级缓存是在不同线程（不同SqlSession）间共享数据</strong></p><h3 id="1-一级查询缓存"><a href="#1-一级查询缓存" class="headerlink" title="1.一级查询缓存"></a>1.一级查询缓存</h3><p>mybatis一级查询缓存是基于org.apache.ibatis.cache.impl.PerpetualCache类的HashMap本地缓存，其作用域是SqlSession，相同的namespace的mapper查询数据库存在同一个缓存区域。不同namespace下的数据互不干扰。在同一个SqlSession中两次执行相同的sql查询语句，第一次执行完毕后，会将查询结果写入到缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。<br>当一个sqlSession结束后，该SqlSession中的一级查询缓存也就不存在来了，mybatis默认一级查询缓存是开启状态的， <strong>且不能关闭</strong> 。</p><h4 id="—从缓存中读取数据的key是SQL的id和sql语句"><a href="#—从缓存中读取数据的key是SQL的id和sql语句" class="headerlink" title="—从缓存中读取数据的key是SQL的id和sql语句"></a>—从缓存中读取数据的key是SQL的id和sql语句</h4><p>缓存底层实现是个map，key是一个hashcode+sql的id+sql语句，value为查询出来的结果集映射成的java对象。</p><h4 id="—增删改操作会清空一级缓存，无论是否提交（commit）"><a href="#—增删改操作会清空一级缓存，无论是否提交（commit）" class="headerlink" title="—增删改操作会清空一级缓存，无论是否提交（commit）"></a>—增删改操作会清空一级缓存，无论是否提交（commit）</h4><h3 id="2-内置二级缓存"><a href="#2-内置二级缓存" class="headerlink" title="2.内置二级缓存"></a>2.内置二级缓存</h3><p>使用二级缓存的目的，不是共享数据，因为MyBatis从缓存中读取数据的依据是SQL的id和sql语句，而并非查询出的对象。所以， <strong>二级缓存中的数据不是为了在多个查询之间共享,而是为了延长该查询结果的保存时间</strong> ，提高系统性能</p><p>mybatis内置的二级缓存为org.apache.ibatis.cache.impl.PerpetualCache</p><h3 id="2-1实体类实现序列化接口"><a href="#2-1实体类实现序列化接口" class="headerlink" title="2.1实体类实现序列化接口:"></a>2.1实体类实现序列化接口:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2mapper映射文件中添加标签"><a href="#2-2mapper映射文件中添加标签" class="headerlink" title="2.2mapper映射文件中添加标签"></a>2.2mapper映射文件中添加<cache>标签</cache></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.pan.dao.IStudentDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"inserStudent"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--parameterMap参数可以省略不写  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--放sql语句,?放属性名  --&gt;</span></span><br><span class="line">insert into student1(name,age,score) values(#&#123;name&#125;,#&#123;age&#125;,#&#123;score&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span><span class="attr">useCache</span>=<span class="string">"false"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">select id,name,age,score from student1 where id=#&#123;xxxx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById2"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">select id,name from student1 where id=#&#123;xxxx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="—二级缓存的配置"><a href="#—二级缓存的配置" class="headerlink" title="—二级缓存的配置"></a>—二级缓存的配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"FIFO"</span> <span class="attr">flushInterval</span>=<span class="string">"10800000"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span> <span class="attr">size</span>=<span class="string">"512"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>eviction:逐出策略。当二级缓存中的对象达到最大值时，就需要通过住处策略将缓存中的对象移出缓存。默认为LRU。常用策略有：<ul><li>FIFO：First In First Out。先进先出</li><li>LRU：List Recently Used，未被使用时间最长的</li></ul></li><li>flushInterval：刷新缓存的时间间隔，单位毫秒。这里的刷新缓存即清空缓存。一般不指定，即当执行增删改时刷新缓存</li><li>readOnly：设置缓存中数据是否只读。只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，者提供了很重要的性能优势。读写的缓存会返回缓存对象的拷贝，这会慢一点，但是安全，因此默认是false。</li><li>size：二级缓存中可以存放的最多对象个数，默认为1024个</li></ul><h4 id="—注意"><a href="#—注意" class="headerlink" title="—注意"></a>—注意</h4><p>增删改同样会清空二级缓存，但是！对于二级缓存的清空，实际上是将key对应的value置为null，而并非将键值对删除。从DB中进行select查询的条件时，在缓存中不存在这个key，或者key存在但是value为null</p><h4 id="—关闭二级缓存"><a href="#—关闭二级缓存" class="headerlink" title="—关闭二级缓存"></a>—关闭二级缓存</h4><p>二级缓存默认开启，若要将其关闭，则需要进行相关设置。根据关闭的范围大小，可以分为全局关闭与局部关闭。</p><p>（1）全局关闭 所谓全局关闭是指，整个应用的二级缓存全部关闭，所有查询均不使用二级缓存。全局开关设置在主配置文件的全局设置settings标签中，该属性为cacheEnabled，设置为false则关闭；设置为true则开启，默认为true。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 关闭二级查询缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）局部关闭 所谓局部关闭，指整个应用的二级缓存时开启的，对于某个select标签查询不适用二级缓存。此时可以单独关闭该select标签的二级缓存。<br>在该要关闭二级缓存的select/标签中，将其属性useCache设置为false，即可关闭该查询的二级缓存，默认为true。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">useCache</span>=<span class="string">"false"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">select * from student where id=#&#123;xxx&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="—二级缓存的使用原则"><a href="#—二级缓存的使用原则" class="headerlink" title="—二级缓存的使用原则"></a>—二级缓存的使用原则</h4><p><strong>1.只能在一个命名空间下使用二级缓存</strong> 由于二级缓存中的数据是基于namespace的，即不同namespace中的数据互不干扰。在多个namespace中若均存在对同一个表的操作，那么这多个namespace中的数据可能会出现不一致</p><p><strong>2.在表单上使用二级缓存</strong> 如果一个表与其他表有关联关系，那么就非常有可能存在多个namespace对同一个数据的操作。而不同namespace中的数据互不干扰，那么这多个namespace中的数据可能会出现不一致</p><p><strong>3.查询多与修改时使用二级缓存</strong> 在查询操作远远多于增删改操作的情况下可以使用二级缓存。因为任何增伤该都会将二级缓存刷新，对二级缓存的频繁刷新将降低系统性能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mybatis用到的动态代理设计模式&quot;&gt;&lt;a href=&quot;#Mybatis用到的动态代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;Mybatis用到的动态代理设计模式:&quot;&gt;&lt;/a&gt;Mybatis用到的动态代理设计模式:&lt;/h3&gt;&lt;h3 id=
      
    
    </summary>
    
    
      <category term="ssm" scheme="http://Homeofpan.github.io/categories/ssm/"/>
    
    
      <category term="mybatis" scheme="http://Homeofpan.github.io/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>springMvc复习笔记</title>
    <link href="http://Homeofpan.github.io/2019/10/13/springMvc%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://Homeofpan.github.io/2019/10/13/springMvc复习笔记/</id>
    <published>2019-10-13T04:06:37.000Z</published>
    <updated>2019-10-13T10:39:43.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理器的种类"><a href="#处理器的种类" class="headerlink" title="处理器的种类:"></a>处理器的种类:</h2><h3 id="1-extends-AbstractController"><a href="#1-extends-AbstractController" class="headerlink" title="1.extends  AbstractController"></a>1.extends  <strong>AbstractController</strong></h3><p>​     当继承了该Controller之后,就必须要实现这个抽象类的handleRequestInternal()方法,因为当请求进来时会先进入handleRequest方法,但是该方法里面使用了模板方法设计模式;并且这个模板方法就是handleRequestInternal(),由于这是子类都必须实现的方法,所以设计为抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delegate to WebContentGenerator for checking and preparing.</span></span><br><span class="line">checkRequest(request);</span><br><span class="line">prepareResponse(response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute handleRequestInternal in synchronized block if required.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line"><span class="keyword">return</span> handleRequestInternal(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handleRequestInternal(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method. Subclasses must implement this.</span></span><br><span class="line"><span class="comment"> * The contract is the same as for &#123;<span class="doctag">@code</span> handleRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handleRequest</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">handleRequestInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><h3 id="SpringMvc的拦截器"><a href="#SpringMvc的拦截器" class="headerlink" title="SpringMvc的拦截器:"></a>SpringMvc的拦截器:</h3><p>   自定义拦截器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMVCInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在 </span></span><br><span class="line"><span class="comment">     * 多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在 </span></span><br><span class="line"><span class="comment">     * Controller方法调用之前调用。SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返 </span></span><br><span class="line"><span class="comment">     * 回值为false，当preHandle的返回值为false的时候整个请求就结束了。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 </span></span><br><span class="line"><span class="comment">     * 后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操 </span></span><br><span class="line"><span class="comment">     * 作。这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像， </span></span><br><span class="line"><span class="comment">     * 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor </span></span><br><span class="line"><span class="comment">     * 或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler,  </span></span></span><br><span class="line"><span class="function"><span class="params">            ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， </span></span><br><span class="line"><span class="comment">     * 这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request,  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response, Object handler, Exception ex)</span>  </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不常用但是比较有用的springMvc后台接收数据的参数方式-map"><a href="#不常用但是比较有用的springMvc后台接收数据的参数方式-map" class="headerlink" title="不常用但是比较有用的springMvc后台接收数据的参数方式:map"></a>不常用但是比较有用的springMvc后台接收数据的参数方式:map</h3><blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><h3 id="1-要在接收map参数的前面加上一个-RequestParam注解-没有对json转换-RequestBody-对json转换"><a href="#1-要在接收map参数的前面加上一个-RequestParam注解-没有对json转换-RequestBody-对json转换" class="headerlink" title="1.要在接收map参数的前面加上一个@RequestParam注解(没有对json转换),@RequestBody(对json转换);"></a>1.要在接收map参数的前面加上一个@RequestParam注解(没有对json转换),@RequestBody(对json转换);</h3><h3 id="2-对前台需要接收很多个参数的时候-建议使用map进行接收-就不用一个一个地去写参数"><a href="#2-对前台需要接收很多个参数的时候-建议使用map进行接收-就不用一个一个地去写参数" class="headerlink" title="2.对前台需要接收很多个参数的时候,建议使用map进行接收,就不用一个一个地去写参数;"></a>2.对前台需要接收很多个参数的时候,建议使用map进行接收,就不用一个一个地去写参数;</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMap</span><span class="params">(@RequestParam Map&lt;String,String&gt; map)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String,String&gt; entry :map.entrySet())&#123;</span><br><span class="line">        <span class="comment">//接收的参数可能是中文会导致乱码(springMvc只解决了get乱码问题)</span></span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        value = <span class="keyword">new</span> String(entry.getValue().getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line">        System.out.println(entry.getKey());</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重点-springMvc的注解开发"><a href="#重点-springMvc的注解开发" class="headerlink" title="重点:springMvc的注解开发:"></a>重点:springMvc的注解开发:</h2><h3 id="一-mvc-annotation-driven"><a href="#一-mvc-annotation-driven" class="headerlink" title="一.mvc:annotation-driven/"></a>一.<a href="mvc:annotation-driven/" target="_blank" rel="noopener">mvc:annotation-driven/</a></h3><blockquote><p>Spring 3.0.x中使用了mvc:annotation-driven后，默认会帮我们注册默认处理请求，参数和返回值的类，其中最主要的两个类：DefaultAnnotationHandlerMapping 和 AnnotationMethodHandlerAdapter ，分别为HandlerMapping的实现类和HandlerAdapter的实现类，从3.1.x版本开始对应实现类改为了RequestMappingHandlerMapping和RequestMappingHandlerAdapter。</p><p>HandlerMapping的实现类的作用:实现类RequestMappingHandlerMapping，它会处理@RequestMapping 注解，并将其注册到请求映射表中。</p><p> HandlerAdapter的实现类的作用:实现类RequestMappingHandlerAdapter，则是处理请求的适配器，确定调用哪个类的哪个方法，并且构造方法参数，返回值。</p><p> 当配置了mvc:annotation-driven/后，Spring就知道了我们启用注解驱动。然后Spring通过context:component-scan/标签的配置，会自动为我们将扫描到的@Component，@Controller，@Service，@Repository等注解标记的组件注册到工厂中，来处理我们的请求。</p></blockquote><h3 id="二-Autowired对静态变量的注入"><a href="#二-Autowired对静态变量的注入" class="headerlink" title="二.@Autowired对静态变量的注入:"></a>二.@Autowired对静态变量的注入:</h3><h3 id="使用场景-某些工具类需要使用dao或者service层的对象时-则要定义该对象为静态对象的时候-需要注入"><a href="#使用场景-某些工具类需要使用dao或者service层的对象时-则要定义该对象为静态对象的时候-需要注入" class="headerlink" title="使用场景:某些工具类需要使用dao或者service层的对象时,则要定义该对象为静态对象的时候,需要注入"></a>使用场景:某些工具类需要使用dao或者service层的对象时,则要定义该对象为静态对象的时候,需要注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DocImageUtils</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ImageFileDao imageFileDao;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DocImageFileDao docImageFileDao;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setDocImageFileDao</span><span class="params">(DocImageFileDao docImageFileDao)</span> </span>&#123;</span><br><span class="line">        DocImageUtils.docImageFileDao = docImageFileDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setImageFileDao</span><span class="params">(ImageFileDao imageFileDao)</span> </span>&#123;</span><br><span class="line">        DocImageUtils.imageFileDao = imageFileDao;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;处理器的种类&quot;&gt;&lt;a href=&quot;#处理器的种类&quot; class=&quot;headerlink&quot; title=&quot;处理器的种类:&quot;&gt;&lt;/a&gt;处理器的种类:&lt;/h2&gt;&lt;h3 id=&quot;1-extends-AbstractController&quot;&gt;&lt;a href=&quot;#1-exten
      
    
    </summary>
    
    
      <category term="ssm" scheme="http://Homeofpan.github.io/categories/ssm/"/>
    
    
      <category term="springmvc" scheme="http://Homeofpan.github.io/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>springMvc请求的过程源码分析</title>
    <link href="http://Homeofpan.github.io/2019/10/12/springMvc%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://Homeofpan.github.io/2019/10/12/springMvc请求的过程源码分析/</id>
    <published>2019-10-12T11:28:40.000Z</published>
    <updated>2019-10-13T07:31:44.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DispatcherServlet是springMvc中的一个关键角色-被称为中央调度器-每个请求都要经过该Servlet的如下方法-至至原生的Servlet在后面会讲解"><a href="#DispatcherServlet是springMvc中的一个关键角色-被称为中央调度器-每个请求都要经过该Servlet的如下方法-至至原生的Servlet在后面会讲解" class="headerlink" title="DispatcherServlet是springMvc中的一个关键角色,被称为中央调度器,每个请求都要经过该Servlet的如下方法(至至原生的Servlet在后面会讲解)"></a>DispatcherServlet是springMvc中的一个关键角色,被称为中央调度器,每个请求都要经过该Servlet的如下方法(至至原生的Servlet在后面会讲解)</h3><h3 id="doPatcher-方法"><a href="#doPatcher-方法" class="headerlink" title="doPatcher()方法:"></a>doPatcher()方法:</h3><h3 id="所有请求到达这里之后会根据这个方法来找到对应的处理器进行处理"><a href="#所有请求到达这里之后会根据这个方法来找到对应的处理器进行处理" class="headerlink" title="所有请求到达这里之后会根据这个方法来找到对应的处理器进行处理."></a>所有请求到达这里之后会根据这个方法来找到对应的处理器进行处理.</h3><blockquote><h3 id="执行的步骤"><a href="#执行的步骤" class="headerlink" title="执行的步骤:"></a>执行的步骤:</h3><h3 id="1-对请求进行判断-是否为mutilpart请求"><a href="#1-对请求进行判断-是否为mutilpart请求" class="headerlink" title="1.对请求进行判断,是否为mutilpart请求"></a>1.对请求进行判断,是否为mutilpart请求</h3><h3 id="2-寻找对应的处理器映射器-HandleMapping-并且和执行器链包装成一个HandlerExecutionChain返回"><a href="#2-寻找对应的处理器映射器-HandleMapping-并且和执行器链包装成一个HandlerExecutionChain返回" class="headerlink" title="2.寻找对应的处理器映射器(HandleMapping),并且和执行器链包装成一个HandlerExecutionChain返回"></a>2.寻找对应的处理器映射器(HandleMapping),并且和执行器链包装成一个HandlerExecutionChain返回</h3><h3 id="3-根据handler来遍历寻找对应的处理器适配器-HandlerAdapter"><a href="#3-根据handler来遍历寻找对应的处理器适配器-HandlerAdapter" class="headerlink" title="3.根据handler来遍历寻找对应的处理器适配器(HandlerAdapter)"></a>3.根据handler来遍历寻找对应的处理器适配器(HandlerAdapter)</h3><h3 id="3-执行拦截器的preHandle方法"><a href="#3-执行拦截器的preHandle方法" class="headerlink" title="3.执行拦截器的preHandle方法"></a>3.执行拦截器的preHandle方法</h3><h3 id="4-执行处理器方法-得到一个ModelAndView对象"><a href="#4-执行处理器方法-得到一个ModelAndView对象" class="headerlink" title="4.执行处理器方法,得到一个ModelAndView对象"></a>4.执行处理器方法,得到一个ModelAndView对象</h3><h3 id="5-根据处理器返回结果来设置ViewName-也就是解析出View视图"><a href="#5-根据处理器返回结果来设置ViewName-也就是解析出View视图" class="headerlink" title="5.根据处理器返回结果来设置ViewName,也就是解析出View视图"></a>5.根据处理器返回结果来设置ViewName,也就是解析出View视图</h3><h3 id="6-执行拦截器的postHandle方法"><a href="#6-执行拦截器的postHandle方法" class="headerlink" title="6.执行拦截器的postHandle方法"></a>6.执行拦截器的postHandle方法</h3><h3 id="7-对mv对象进行一些处理-查看是否存在异常情况-如果出现则使用异常解析器进行相关的处理"><a href="#7-对mv对象进行一些处理-查看是否存在异常情况-如果出现则使用异常解析器进行相关的处理" class="headerlink" title="7.对mv对象进行一些处理,查看是否存在异常情况,如果出现则使用异常解析器进行相关的处理"></a>7.对mv对象进行一些处理,查看是否存在异常情况,如果出现则使用异常解析器进行相关的处理</h3><h3 id="8-调用拦截器的afterCompletion方法"><a href="#8-调用拦截器的afterCompletion方法" class="headerlink" title="8.调用拦截器的afterCompletion方法"></a>8.调用拦截器的afterCompletion方法</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the actual dispatching to the handler.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order.</span></span><br><span class="line"><span class="comment"> * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters</span></span><br><span class="line"><span class="comment"> * to find the first that supports the handler class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers</span></span><br><span class="line"><span class="comment"> * themselves to decide which methods are acceptable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of any kind of processing failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//先保留一份进来的请求,因为后面用来判断是否是Mutipart请求</span></span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">        <span class="comment">//定义执行器链,这个类包装了handlemapping在里面</span></span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//标志是否为MultipartRequest</span></span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里真正判断是否为MultipartRequest</span></span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">                <span class="comment">// 获取Request对应的处理器映射器</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">                <span class="comment">//能执行到这里需要找到对应的handle</span></span><br><span class="line">                <span class="comment">//根据上面的方法匹配到的handle来找到对应的处理器适配器</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//执行拦截器的PreHandle方法()</span></span><br><span class="line">                <span class="comment">//由此可见,该方法在处理器执行之前执行,并且return false之后就不会执行处理器方法</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">                <span class="comment">//真正执行Handler对应的方法,并且返回ModelAndView</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断mv中是否设置了viewName,如果没有就默认帮你设置</span></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">                <span class="comment">//执行拦截器的postHandle方法(拦截处理程序的执行。在HandlerAdapter实际调用处理程序之后调                  // 用，但是在DispatcherServlet呈现视图之前调用。)</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//对handler执行方法完成之后返回的结果进行处理,针对返回ModelAndView和异常的发生</span></span><br><span class="line">            <span class="comment">//这个方法的最后一步是对前面拦截器的PostHandle方法成功的拦截器进行回调,去执行拦截器</span></span><br><span class="line">            <span class="comment">//的另一个方法afterCompletion</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取处理器映射器的方法-最终返回的是与处理器执行链的包装对象"><a href="#获取处理器映射器的方法-最终返回的是与处理器执行链的包装对象" class="headerlink" title="获取处理器映射器的方法(最终返回的是与处理器执行链的包装对象)"></a>获取处理器映射器的方法(最终返回的是与处理器执行链的包装对象)</h3><h3 id="getHandle-方法"><a href="#getHandle-方法" class="headerlink" title="getHandle()方法:"></a>getHandle()方法:</h3><p>​     1.遍历一个有所有HandleMapping的List: List<handlermapping> handlerMappings;</handlermapping></p><p>​        HandleMapping是一个接口有许多的实现,根据不同的情况来选择不同的处理器映射器</p><p>​     2.一个HandMapping中许多个Handle,要根据url来寻找对应的Handle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the HandlerExecutionChain for this request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Tries all handler mappings in order.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the HandlerExecutionChain, or &#123;<span class="doctag">@code</span> null&#125; if no handler could be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(</span><br><span class="line"><span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//根据对应的处理器映射器获取对应的处理器</span></span><br><span class="line">            <span class="comment">//这里特指那些自定义的Controller,xml形式的或注解形式的</span></span><br><span class="line">HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getHandler-request-根据URL获取对应的Handle"><a href="#getHandler-request-根据URL获取对应的Handle" class="headerlink" title="getHandler(request):根据URL获取对应的Handle"></a>getHandler(request):根据URL获取对应的Handle</h3><blockquote><h4 id="1-根据URL来查询对应的Handle"><a href="#1-根据URL来查询对应的Handle" class="headerlink" title="1.根据URL来查询对应的Handle"></a>1.根据URL来查询对应的Handle</h4><h3 id="2-获取处理器执行链-其实将handle的封装在同一个对象"><a href="#2-获取处理器执行链-其实将handle的封装在同一个对象" class="headerlink" title="2.获取处理器执行链(其实将handle的封装在同一个对象)"></a>2.获取处理器执行链(其实将handle的封装在同一个对象)</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look up a handler for the given request, falling back to the default</span></span><br><span class="line"><span class="comment"> * handler if no specific one is found.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the corresponding handler instance, or the default handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getHandlerInternal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">Object handler = getHandlerInternal(request);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">handler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取处理器执行链(其实将handle的封装在同一个对象)</span></span><br><span class="line">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"><span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">CorsConfiguration globalConfig = <span class="keyword">this</span>.corsConfigSource.getCorsConfiguration(request);</span><br><span class="line">CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">CorsConfiguration config = (globalConfig != <span class="keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="getHandlerInternal-request-：根据URL真正查找用户定义的Controller-Handle"><a href="#getHandlerInternal-request-：根据URL真正查找用户定义的Controller-Handle" class="headerlink" title="getHandlerInternal(request)：根据URL真正查找用户定义的Controller(Handle)"></a>getHandlerInternal(request)：根据URL真正查找用户定义的Controller(Handle)</h3><blockquote><h3 id="全程都需要加锁"><a href="#全程都需要加锁" class="headerlink" title="全程都需要加锁"></a>全程都需要加锁</h3><p>1.获取请求的url</p><p>2.获取对应url所定义的方法</p><p>3.如果找到对应的方法则返回Handle(Controller)实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look up a handler method for the given request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取@RequestMapping中对应的url</span></span><br><span class="line">String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Looking up handler method for path "</span> + lookupPath);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//mappingRegistry:这个类用来保存所有注册的处理器映射器;类里面存在hashMap来存放处理器映射器</span></span><br><span class="line">        <span class="comment">//key为url,value为对应的方法</span></span><br><span class="line">        <span class="comment">//这里对该对象加了一个读锁</span></span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取对应url所定义的方法(执行的方法)</span></span><br><span class="line">HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (handlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.debug(<span class="string">"Returning handler method ["</span> + handlerMethod + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">"Did not find handler method for ["</span> + lookupPath + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//如果根据url找到对应的handleMethod(处理器方法)</span></span><br><span class="line">            <span class="comment">//createWithResolvedBean():根据getBean方法获取容器中对应的Handle实例</span></span><br><span class="line"><span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getHandlerAdapter-Object-handler-获取对应的处理器适配器"><a href="#getHandlerAdapter-Object-handler-获取对应的处理器适配器" class="headerlink" title="getHandlerAdapter(Object handler):获取对应的处理器适配器"></a>getHandlerAdapter(Object handler):获取对应的处理器适配器</h3><blockquote><p>1.遍历一个Servlet中所有处理器适配器的List;private List<handleradapter> handlerAdapters;</handleradapter></p><p>2.找到一个与handler对应的处理器适配器</p><h3 id="这里涉及到适配器设计模式-根据不同的适配器做不同的东西"><a href="#这里涉及到适配器设计模式-根据不同的适配器做不同的东西" class="headerlink" title="这里涉及到适配器设计模式:根据不同的适配器做不同的东西"></a>这里涉及到适配器设计模式:根据不同的适配器做不同的东西</h3></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the HandlerAdapter for this handler object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler object to find an adapter for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if no HandlerAdapter can be found for the handler. This is a fatal error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//根据handler来匹配相应的处理器适配器</span></span><br><span class="line"><span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line"><span class="keyword">return</span> ha;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</span><br><span class="line"><span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DispatcherServlet是springMvc中的一个关键角色-被称为中央调度器-每个请求都要经过该Servlet的如下方法-至至原生的Servlet在后面会讲解&quot;&gt;&lt;a href=&quot;#DispatcherServlet是springMvc中的一个关键角色
      
    
    </summary>
    
    
      <category term="ssm" scheme="http://Homeofpan.github.io/categories/ssm/"/>
    
    
      <category term="springMvc" scheme="http://Homeofpan.github.io/tags/springMvc/"/>
    
  </entry>
  
  <entry>
    <title>spring事务的传播行为</title>
    <link href="http://Homeofpan.github.io/2019/10/11/spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/"/>
    <id>http://Homeofpan.github.io/2019/10/11/spring事务的传播行为/</id>
    <published>2019-10-11T07:49:32.000Z</published>
    <updated>2019-10-11T07:53:30.827Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务传播行为介绍"><a href="#事务传播行为介绍" class="headerlink" title="事务传播行为介绍"></a>事务传播行为介绍</h3><h2 id="Spring中的7个事务传播行为"><a href="#Spring中的7个事务传播行为" class="headerlink" title="Spring中的7个事务传播行为:"></a>Spring中的7个事务传播行为:</h2><p>事务行为    说明<br>PROPAGATION_REQUIRED    支持当前事务，假设当前没有事务。就新建一个事务<br>PROPAGATION_SUPPORTS    支持当前事务，假设当前没有事务，就以非事务方式运行<br>PROPAGATION_MANDATORY    支持当前事务，假设当前没有事务，就抛出异常<br>PROPAGATION_REQUIRES_NEW    新建事务，假设当前存在事务。把当前事务挂起<br>PROPAGATION_NOT_SUPPORTED    以非事务方式运行操作。假设当前存在事务，就把当前事务挂起<br>PROPAGATION_NEVER    以非事务方式运行，假设当前存在事务，则抛出异常<br>PROPAGATION_NESTED    如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p><h2 id="Spring异常事务处理机制"><a href="#Spring异常事务处理机制" class="headerlink" title="Spring异常事务处理机制:"></a>Spring异常事务处理机制:</h2><p>1、事务注解一般用在业务层</p><p>2、在业务逻辑中抛出的异常若是被try-catch了，事务是无法回滚的，所以正确的操作是在遇到异常场景需要回滚时，手动抛出RuntimeException(默认情况下Spring 中的事务处理只对RuntimeException 方法进行回滚，所以，如果<br>将Runtime Exception 替换成普通的Exception 不会产生回滚效果。 )</p><p>3、spring中的事务是以AOP为基础的，是应用代理模式实现的</p><p>4、Spring实现事务时，提取事务标签的顺序为：方法事务声明–&gt;方法所在类事务声明–&gt;接口方法事务声明–&gt;接口方法所在类事务声明</p><p>5、对于事务处理，最重要的是要获取事务对应的属性，如果没有事务对应的属性值，事务将无从处理，事务的所有信息从创建事务开始就保存在transactionInfo中，包括事务回滚都要依赖该信息进行处理。</p><p>6、事务回滚处理(Spring处理异常事务机制）</p><pre><code>(1)事务回滚条件    Spring事务异常处理机制只会对RuntimeException 和Error 级别的异常执行回滚操作，执行具体回滚的函数如下：   public boolean rollbackOn(Throwable ex) {                return (ex instanceof RuntimeException || ex instanceof Error);   }  当然我们可以对上述两种类型的异常进行扩展处理，达到自己对指定常的回滚，并利用注解的方式实现 @Transactional(rollbackFor =  xxxException.class)(2)事务回滚处理 两步：    触发器监听函数      执行真正的回滚操作，在执行回滚操作的时候要考虑是否有嵌套事务（根据       savePoint来判断，若有嵌套事务，则对嵌套事务单独进行回滚，不回滚外事务。）(3) 回滚后的信息清除   无论事务是否回滚成功都必须执行     设置事务状态为完成，避免事务重复执行     如果当前事务是新的同步状态，则将事务信息从当前线程中清除掉     释放事务占用的资源(数据库连接资源等)    如果在当前事务事前有事务挂起，需要将挂起的事务恢复</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;事务传播行为介绍&quot;&gt;&lt;a href=&quot;#事务传播行为介绍&quot; class=&quot;headerlink&quot; title=&quot;事务传播行为介绍&quot;&gt;&lt;/a&gt;事务传播行为介绍&lt;/h3&gt;&lt;h2 id=&quot;Spring中的7个事务传播行为&quot;&gt;&lt;a href=&quot;#Spring中的7个事务传
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://Homeofpan.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="spring" scheme="http://Homeofpan.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的加锁分析情况</title>
    <link href="http://Homeofpan.github.io/2019/10/11/Mysql%E7%9A%84%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90%E6%83%85%E5%86%B5/"/>
    <id>http://Homeofpan.github.io/2019/10/11/Mysql的加锁分析情况/</id>
    <published>2019-10-11T06:38:35.000Z</published>
    <updated>2019-10-11T07:24:22.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引和锁的分析"><a href="#索引和锁的分析" class="headerlink" title="索引和锁的分析"></a><strong>索引和锁的分析</strong></h1><p>依旧，基于InnoDB</p><h2 id="再补充一点前提"><a href="#再补充一点前提" class="headerlink" title="再补充一点前提"></a><strong>再补充一点前提</strong></h2><h3 id="1-2PL：Two-Phase-Locking"><a href="#1-2PL：Two-Phase-Locking" class="headerlink" title="1.2PL：Two-Phase Locking"></a>1.2PL：Two-Phase Locking</h3><p>传统RDBMS加锁的一个原则，就是2PL (二阶段锁)：Two-Phase Locking。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：加锁阶段与解锁阶段，并且保证加锁阶段与解锁阶段不相交。下面，仍旧以MySQL为例，来简单看看2PL在MySQL中的实现。 <img src="http://irats.cn:8888/group1/M00/00/00/rBECIl1eEnGAH-UXAACZSj41twA342.jpg" alt="二阶段锁"></p><p>2PL就是将加锁/解锁分为两个完全不相交的阶段。加锁阶段：只加锁，不放锁。解锁阶段：只放锁，不加锁。</p><h2 id="2-Isolation-Level（事务级别）"><a href="#2-Isolation-Level（事务级别）" class="headerlink" title="2.Isolation Level（事务级别）"></a>2.Isolation Level（事务级别）</h2><p>隔离级别：Isolation Level，也是RDBMS的一个关键特性。 MySQL/InnoDB定义的4种隔离级别： •    Read Uncommited 可以读取未提交记录。此隔离级别，基本不会使用。</p><p>•    Read Committed (RC) 快照读忽略，第一篇文章写的很清楚了。 针对当前读，RC隔离级别保证对读取到的记录加锁 (记录锁)，存在幻读现象。</p><p>•    Repeatable Read (RR) 快照读忽略，第一篇文章写的很清楚了。 针对当前读，RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，不存在幻读现象。</p><p>•    Serializable 从MVCC并发控制退化为基于锁的并发控制。不区别快照读与当前读，所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。 Serializable隔离级别下，读写冲突，因此并发度急剧下降，不建议使用。</p><h2 id="简单SQL的加锁实现分析"><a href="#简单SQL的加锁实现分析" class="headerlink" title="简单SQL的加锁实现分析"></a><strong>简单SQL的加锁实现分析</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">•SQL1：select * from t1 where id = 10;</span><br><span class="line">•SQL2：delete from t1 where id = 10;</span><br></pre></td></tr></table></figure><p>对于上面两条sql语句，需要分析则必须明确下面几点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">•一：id列是不是主键？</span><br><span class="line">•二：当前系统的隔离级别是什么？</span><br><span class="line">•三：id列如果不是主键，那么id列上有索引吗？</span><br><span class="line">•四：id列上如果有二级索引，那么这个索引是唯一索引吗？</span><br><span class="line">•五：两个SQL的执行计划是什么？索引扫描？全表扫描？</span><br></pre></td></tr></table></figure><p>没有给定上述几点，分析都是假的 根据上面的条件，将sql分为如下组合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">•组合一：id列是主键，RC隔离级别</span><br><span class="line">•组合二：id列是二级唯一索引，RC隔离级别</span><br><span class="line">•组合三：id列是二级非唯一索引，RC隔离级别</span><br><span class="line">•组合四：id列上没有索引，RC隔离级别</span><br><span class="line">•组合五：id列是主键，RR隔离级别</span><br><span class="line">•组合六：id列是二级唯一索引，RR隔离级别</span><br><span class="line">•组合七：id列是二级非唯一索引，RR隔离级别</span><br><span class="line">•组合八：id列上没有索引，RR隔离级别</span><br><span class="line">•组合九：Serializable隔离级别</span><br></pre></td></tr></table></figure><p>下面开始分析：</p><h3 id="组合一：id主键-RC"><a href="#组合一：id主键-RC" class="headerlink" title="组合一：id主键+RC"></a><strong>组合一：id主键+RC</strong></h3><p>id是主键，Read Committed隔离级别，给定SQL：delete from t1 where id = 10; 只需要将主键上，id = 10的记录加上X锁即可。如下图所示： <img src="http://irats.cn:8888/group1/M00/00/00/rBECIl1eFVyAU3G8AACB0n3pKWY418.jpg" alt="id主键+RC"></p><p><strong>结论：</strong> id是主键时，此SQL只需要在id=10这条记录上加X锁即可。</p><h3 id="组合二：id唯一索引-RC"><a href="#组合二：id唯一索引-RC" class="headerlink" title="组合二：id唯一索引+RC"></a><strong>组合二：id唯一索引+RC</strong></h3><p>id不是主键，而是一个Unique的二级索引键值。那么在RC隔离级别下，delete from t1 where id = 10; 需要加什么锁呢？见下图： <img src="http://irats.cn:8888/group1/M00/00/00/rBECIl1eFaaAAuTTAACTl8kxySw303.jpg" alt="id唯一索引+RC"></p><p>此组合中，id是unique索引，而主键是name列。此时，加锁的情况由于组合一有所不同。由于id是unique索引，因此delete语句会选择走id列的索引进行where条件的过滤，在找到id=10的记录后，首先会将unique索引上的id=10索引记录加上X锁，同时，会根据读取到的name列，回主键索引(聚簇索引)，然后将聚簇索引上的name = ‘d’ 对应的主键索引项加X锁。为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：update t1 set id = 100 where name = ‘d’; 此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p><p><strong>结论：</strong> 若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</p><h3 id="组合三：id非唯一索引-RC"><a href="#组合三：id非唯一索引-RC" class="headerlink" title="组合三：id非唯一索引+RC"></a><strong>组合三：id非唯一索引+RC</strong></h3><p>id列上的约束相比组合一、二 又降低了，id不再是唯一列，只有一个普通索引。假设delete from t1 where id = 10; 语句，仍旧选择id列上的索引进行过滤where条件，那么此时会持有哪些锁？同样见下图： <img src="http://irats.cn:8888/group1/M00/00/00/rBECIl1eFm2AHi6yAACXA5-E1HY180.jpg" alt="id非唯一索引+RC"></p><p>可以看出，首先，id列索引上，满足id=10的查询条件的记录，均已加上锁。同时，这些记录对应的主键索引上的记录也都加上所。与组合二唯一的区别在于，组合二最多只有一个满足等值查询的记录，二组合三会将所有满足查询的记录都加锁。</p><p><strong>结论：</strong> 若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p><h3 id="组合四：id无索引-RC"><a href="#组合四：id无索引-RC" class="headerlink" title="组合四：id无索引+RC"></a><strong>组合四：id无索引+RC</strong></h3><p>相对于前面三个组合，这是一个比较特殊的情况。id列上没有索引，where id = 10;这个过滤条件，没法通过索引进行过滤，那么只能走全表扫描做过滤。对应于这个组合，SQL会加什么锁？或者是换句话说，全表扫描时，会加什么锁？这个答案也有很多：有人说会在表上加X锁；有人说会将聚簇索引上，选择出来的id = 10;的记录加上X锁。那么实际情况呢？请看下图： <img src="http://irats.cn:8888/group1/M00/00/00/rBECIl1eFxaAHv5CAACbIC-obTo771.jpg" alt="id无索引+RC"></p><p>由于id列上没有索引，因此只能走聚簇索引，进行全部扫描。从图中可以看到，满足删除条件的记录有两条，但是，聚簇索引上所有的记录，都被加上了X锁。无论记录是否满足条件，全部被加上X锁。既不是加表锁，也不是在满足条件的记录上加行锁。</p><p>有人可能会问？为什么不是只在满足条件的记录上加锁呢？这是由于MySQL的实现决定的。如果一个条件无法通过索引快速过滤，那么存储引擎层面就会将所有记录加锁后返回，然后由MySQL Server层进行过滤。因此也就把所有的记录，都锁上了。</p><p><strong>注：</strong> 在实际的实现中，MySQL有一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁 (违背了2PL的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。</p><p><strong>结论：</strong> 若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</p><hr><h3 id="组合五：id主键-RR"><a href="#组合五：id主键-RR" class="headerlink" title="组合五：id主键+RR"></a><strong>组合五：id主键+RR</strong></h3><p>上面的四个组合，都是在Read Committed隔离级别下的加锁行为，接下来的四个组合，是在Repeatable Read隔离级别下的加锁行为。 组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[id主键，Read Committed]一致。</p><h3 id="组合六：id唯一索引-RR"><a href="#组合六：id唯一索引-RR" class="headerlink" title="组合六：id唯一索引+RR"></a><strong>组合六：id唯一索引+RR</strong></h3><p>与组合五类似，组合六的加锁，与组合二：[id唯一索引，Read Committed]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p><h3 id="组合七：id非唯一索引-RR"><a href="#组合七：id非唯一索引-RR" class="headerlink" title="组合七：id非唯一索引+RR"></a><strong>组合七：id非唯一索引+RR</strong></h3><p>是否记得上面所提的隔离级别，RC隔离级别允许幻读，而RR隔离级别不允许幻读。如果对脏读、幻读、可重复度等不清楚的话，有空再来写关于这几个读的区别。</p><p>现在简单说下幻读：如果一个事务第一次进行当前读id=10读取到三条数据，第二次进行当前读之前，其他事物插入了一条id=10的数据，第二次当前读id=10就会有四条数据，这就是幻读，就好像第一次出现了幻觉，第二次明明是四条，第一次怎么是三条？</p><p>组合七，Repeatable Read隔离级别，id上有一个非唯一索引，执行delete from t1 where id = 10; 假设选择id列上的索引进行条件过滤，最后的加锁行为，是怎么样的呢？同样看下面这幅图: <img src="http://irats.cn:8888/group1/M00/00/00/rBECIl1eGTiABq3wAACP_3bsPjw465.jpg" alt="id非唯一索引+RR"></p><p>此图，相对于组合三：[id列上非唯一锁，Read Committed]看似相同，其实却有很大的区别。最大的区别在于，这幅图中多了一个GAP锁，而且GAP锁看起来也不是加在记录上的，倒像是加载两条记录之间的位置，GAP锁有何用？</p><p><strong>注：</strong> GAP锁也叫间隙锁，有空再解释</p><p>其实这个多出来的GAP锁，就是RR隔离级别，相对于RC隔离级别，不会出现幻读的关键。确实，GAP锁锁住的位置，也不是记录本身，而是两条记录之间的GAP。所谓幻读，就是同一个事务，连续做两次当前读 (例如：select * from t1 where id = 10 for update;)，那么这两次当前读返回的是完全相同的记录 (记录数量一致，记录本身也一致)，第二次的当前读，不会比第一次返回更多的记录 (幻象)。</p><p>如何保证两次当前读返回一致的记录，那就需要在第一次当前读与第二次当前读之间，其他的事务不会插入新的满足条件的记录并提交。为了实现这个功能，GAP锁应运而生。</p><p>如图中所示，有哪些位置可以插入新的满足条件的项 (id = 10)，考虑到B+树索引的有序性，满足条件的项一定是连续存放的。记录[6,c]之前，不会插入id=10的记录；[6,c]与[10,b]间可以插入[10, aa] <strong>(注意,这里的间隙锁锁住了id=7,8,9,10,如果插入id为6和11的数据是可以的)</strong> ；[10,b]与[10,d]间，可以插入新的[10,bb],[10,c]等；[10,d]与[11,f]间可以插入满足条件的[10,e],[10,z]等；而[11,f]之后也不会插入满足条件的记录。因此，为了保证[6,c]与[10,b]间，[10,b]与[10,d]间，[10,d]与[11,f]不会插入新的满足条件的记录，MySQL选择了用GAP锁，将这三个GAP给锁起来。</p><p>Insert操作，如insert [10,aa]，首先会定位到[6,c]与[10,b]间，然后在插入前，会检查这个GAP是否已经被锁上，如果被锁上，则Insert不能插入记录。因此，通过第一遍的当前读，不仅将满足条件的记录锁上 (X锁)，与组合三类似。同时还是增加3把GAP锁，将可能插入满足条件记录的3个GAP给锁上，保证后续的Insert不能插入新的id=10的记录，也就杜绝了同一事务的第二次当前读，出现幻象的情况。</p><blockquote><p>现在有个问题：为什么组合五、六不加GAP锁？<br>答案很简单，因为组合五、六只会查出一条数据，不存在查询出多条的情况，所以不需要GAP锁</p></blockquote><blockquote><p>再来个问题：如果组合五、六中进行当前读：<br>select * from user where id = 8 for update<br>但是id=8的数据并不存在，那么GAP锁会不会出来现？</p></blockquote><p>下面用实验来说明<br><strong>组合五，id为主键，RR隔离级别</strong><br>Client A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line">- 结果</span><br><span class="line">| id | name |</span><br><span class="line">|  3 | zz   |</span><br><span class="line">|  6 | e    |</span><br><span class="line">| 10 | b    |</span><br><span class="line">| 11 | d    |</span><br><span class="line">| 13 | z    |</span><br><span class="line"></span><br><span class="line">-关闭自动提交事务</span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>Client B</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">'f'</span>); - success</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">'f'</span>); - blocked</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">'f'</span>); - success</span><br></pre></td></tr></table></figure><p>Client A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>可以发现锁的范围是id:[7,9]<br><strong>组合六，id为唯一索引，RR隔离级别</strong><br>Client A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line">- 结果</span><br><span class="line">| id | name |</span><br><span class="line">|  3 | zz   |</span><br><span class="line">|  6 | e    |</span><br><span class="line">| 10 | b    |</span><br><span class="line">| 11 | d    |</span><br><span class="line">| 13 | z    |</span><br><span class="line"></span><br><span class="line">-关闭自动提交事务</span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>Client B</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">'f'</span>); - blocked</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">'f'</span>); - blocked</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">'f'</span>); - blocked</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'f'</span>); - success</span><br></pre></td></tr></table></figure><p>Client A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>可以发现锁的范围是id:[7-9]</p><p><strong>总结：</strong> 当id为聚簇索引（主键）时和当id为唯一索引时进行当前读不存在的数据，就会来个GAP锁，锁住一个范围</p><blockquote><p>现在在又一个问题：<br>在当前组合id非唯一索引+RR，如果select * from test where id = 8 for update,id=8的数据并不存在</p></blockquote><p>实验分析： Client A：关闭事务自动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line">- 结果</span><br><span class="line">| id | name |</span><br><span class="line">|  3 | zz   |</span><br><span class="line">|  6 | e    |</span><br><span class="line">| 10 | b    |</span><br><span class="line">| 11 | d    |</span><br><span class="line">| 13 | z    |</span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>Client B：自动提交事务的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">7</span>/<span class="number">8</span>/<span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>; -返回空，并不blocked</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">6</span> <span class="keyword">for</span> <span class="keyword">update</span>; -返回空，并不blocked</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>; -返回空，并不blocked</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">7</span>/<span class="number">8</span>/<span class="number">9</span>; -直接返回删除成功，这三条数据本来就不存在</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'bb'</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">7</span>/<span class="number">8</span>/<span class="number">9</span>; -直接返回更新成功，但是这些数据并不存在</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">7</span>/<span class="number">8</span>/<span class="number">9</span>,<span class="string">'aaa'</span>); -blocked</span><br><span class="line"></span><br><span class="line">-可以看出，我们同样用<span class="keyword">select</span> <span class="keyword">for</span> <span class="keyword">update</span>查询<span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span>是不会被阻塞的，<span class="keyword">delete</span>、updater操作不存在的数据同样也不会被阻塞</span><br><span class="line">-可是之前不是说了<span class="keyword">select</span> <span class="keyword">for</span> <span class="keyword">update</span>会加X锁吗？</span><br><span class="line">-仅仅是使用<span class="keyword">Insert</span>等语句就会被阻塞</span><br><span class="line">-所以我们给个假设：如果<span class="keyword">select</span> <span class="keyword">for</span> <span class="keyword">update</span>查询不存在的索引，加的不是X锁，而是S锁</span><br><span class="line">-下面继续实验，</span><br></pre></td></tr></table></figure><p>Client A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">'aaa'</span>);</span><br></pre></td></tr></table></figure><p>Client B</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>; -blocked</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">7</span> <span class="keyword">for</span> <span class="keyword">update</span>; -返回空</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">9</span> <span class="keyword">for</span> <span class="keyword">update</span>; -返回空</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">'aaa'</span>); -blocked</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">'aaa'</span>); -blocked</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">'aaa'</span>); -blocked</span><br><span class="line">-当A插入了id=8的数据后，id=8的数据立即被锁定：X锁</span><br><span class="line">-到这里，我们在补充下上面的假设</span><br><span class="line">-如果<span class="keyword">select</span> <span class="keyword">for</span> <span class="keyword">update</span>查询不存在的索引，加的不是X锁，而是S锁</span><br><span class="line">-如果<span class="keyword">insert</span>这条不存在的数据后，这条数据会立刻被<span class="keyword">insert</span>的客户端加以X锁以替代S锁</span><br></pre></td></tr></table></figure><p>Client A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> autocommit = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>现在我们来证明下刚才的假设<br><strong>如果select for update查询不存在的索引，加的不是X锁，而是S锁，如果A客户端insert这条不存在的数据后，这条数据会立刻被insert的客户端加以X锁以替代S锁</strong></p><p>实验：恢复数据，将刚刚插入的id=8的数据删掉，重新实验<br>Client A ：关闭事务自动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>Client B ：关闭事务自动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>Client A ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span> <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">'aaa'</span>); -blocked</span><br><span class="line">-进入阻塞了！！！前半段的假设成立了</span><br><span class="line">-如果<span class="keyword">select</span> <span class="keyword">for</span> <span class="keyword">update</span>查询不存在的索引，加的不是X锁，而是S锁</span><br></pre></td></tr></table></figure><p>Client B：在上面A超时前提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>Client A数据插入成功，此时B再来尝试当前度id=8的数据<br>Client B</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>; - blocked</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">7</span> <span class="keyword">for</span> <span class="keyword">update</span>; -返回空</span><br></pre></td></tr></table></figure><p>假设完全成立了。B会被阻塞，说明A对id=8的数据加以X锁， 但是对于id=7这个不存在的数据，是能够读取的，仍然是S锁.</p><p><strong>在id为非唯一索引，RR隔离级别下，如果select for update查询不存在的索引，加的GAP锁不是X锁类型的，而是S锁类型的，如果A客户端insert这条不存在的数据后，这条数据会立刻被insert的客户端加以X锁以替代S锁，简单来说，GAP对于不存在的数据加的是S锁，对存在的数据加的是X锁</strong><br><strong>如果是使用delete和update语句操作不存在的id数据项，会直接操作成功，因为本来就没什么好操作的</strong></p><p>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p><h3 id="组合八：id无索引-RR"><a href="#组合八：id无索引-RR" class="headerlink" title="**组合八：id无索引+RR"></a><strong>**组合八：id无索引+RR</strong></h3><p>组合八，Repeatable Read隔离级别下的最后一种情况，id列上没有索引。此时SQL：delete from t1 where id = 10; 没有其他的路径可以选择，只能进行全表扫描。最终的加锁情况，如下图所示： <img src="http://irats.cn:8888/group1/M00/00/00/rBECIl1eHwGAZlqXAAC8aV4ARTs433.jpg" alt="id无索引+RR"></p><p>如图，这是一个很恐怖的现象。首先，聚簇索引上的所有记录，都被加上了X锁。其次，聚簇索引每条记录间的间隙(GAP)，也同时被加上了GAP锁。这个示例表，只有6条记录，一共需要6个记录锁，7个GAP锁。试想，如果表上有1000万条记录呢？</p><p>在这种情况下，这个表上，除了不加锁的快照度，其他任何加锁的并发SQL，均不能执行，不能更新，不能删除，不能插入，全表被锁死。</p><p>当然，跟组合四：[id无索引, Read Committed]类似，这个情况下，MySQL也做了一些优化，就是所谓的semi-consistent read。semi-consistent read开启的情况下，对于不满足查询条件的记录，MySQL会提前放锁。针对上面的这个用例，就是除了记录[d,10]，[g,10]之外，所有的记录锁都会被释放，同时不加GAP锁。semi-consistent read如何触发：要么是read committed隔离级别；要么是Repeatable Read隔离级别，同时设置了 innodb_locks_unsafe_for_binlog 参数。</p><p>结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p><h3 id="组合九：Serializable"><a href="#组合九：Serializable" class="headerlink" title="组合九：Serializable"></a><strong>组合九：Serializable</strong></h3><p>针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。 Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。 结论：在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p><h3 id="四、死锁原理与分析"><a href="#四、死锁原理与分析" class="headerlink" title="四、死锁原理与分析"></a><strong>四、死锁原理与分析</strong></h3><p>本文前面的部分，基本上已经涵盖了MySQL/InnoDB所有的加锁规则。深入理解MySQL如何加锁，有两个比较重要的作用：</p><ul><li>可以根据MySQL的加锁规则，写出不会发生死锁的SQL；</li></ul><ul><li>可以根据MySQL的加锁规则，定位出线上产生死锁的原因；</li></ul><p>下面，来看看两个死锁的例子 (一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁)：</p><p><a href="http://officialblog-wordpress.stor.sinaapp.com/uploads/2013/12/medish-10.jpg" target="_blank" rel="noopener"><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2013/12/medish-10.jpg" alt="medish (10)"></a></p><p><a href="http://officialblog-wordpress.stor.sinaapp.com/uploads/2013/12/medish-11.jpg" target="_blank" rel="noopener"><img src="http://officialblog-wordpress.stor.sinaapp.com/uploads/2013/12/medish-11.jpg" alt="medish (11)"></a></p><p>上面的两个死锁用例。第一个非常好理解，也是最常见的死锁，每个事务执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁。</p><p>第二个用例，虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</p><p><strong>结论：</strong>死锁的发生与否，并不在于事务中有多少条SQL语句，<strong>死锁的关键在于</strong>：两个(或以上)的Session<strong>加锁的顺序</strong>不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;索引和锁的分析&quot;&gt;&lt;a href=&quot;#索引和锁的分析&quot; class=&quot;headerlink&quot; title=&quot;索引和锁的分析&quot;&gt;&lt;/a&gt;&lt;strong&gt;索引和锁的分析&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;依旧，基于InnoDB&lt;/p&gt;
&lt;h2 id=&quot;再补充一点前提&quot;&gt;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://Homeofpan.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://Homeofpan.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>当前读与快照读的区别</title>
    <link href="http://Homeofpan.github.io/2019/10/09/%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%8E%E5%BF%AB%E7%85%A7%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://Homeofpan.github.io/2019/10/09/当前读与快照读的区别/</id>
    <published>2019-10-09T07:07:41.000Z</published>
    <updated>2019-10-11T04:02:11.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于Innodb存储引擎的快照读与当前读分析"><a href="#基于Innodb存储引擎的快照读与当前读分析" class="headerlink" title="基于Innodb存储引擎的快照读与当前读分析:"></a>基于Innodb存储引擎的快照读与当前读分析:</h3><h2 id="1-MVCC"><a href="#1-MVCC" class="headerlink" title="1.MVCC"></a>1.MVCC</h2><p>MySQL InnoDB存储引擎 ，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处：读不加锁，读写不冲突。 在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</p><h2 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h2><ul><li><strong>快照读:</strong>最简单的select操作,属于快照读,不加锁<br>select * from table where id = 1;</li><li><strong>当前读:</strong>特殊的读与增删改操作,属于当前读,会读取数据库原本的数据,加锁<br>select * from table where xxx lock in share mode; (共享锁)<br>select * from table where xxx for update;<br>insert into table values()<br>update table set xxx where xxx<br>delete form table where xxx</li></ul><p>以上语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p><h3 id="下面以实例来详解快照读与当前读"><a href="#下面以实例来详解快照读与当前读" class="headerlink" title="下面以实例来详解快照读与当前读:"></a>下面以实例来详解快照读与当前读:</h3><p>在数据库中存在user表并且有4条数据</p><h3 id="1-select快照读-照片"><a href="#1-select快照读-照片" class="headerlink" title="1.select快照读(照片):"></a>1.select快照读(照片):</h3><h4 id="当你执行select-之后，在A与B事务中都会返回4条一样的数据，这是不用想的，当执行select的时候，innodb默认会执行快照读，相当于就是给你目前的状态找了一张照片，以后执行select-的时候就会返回当前照片里面的数据，当其他事务提交了也对你不造成影响，和你没关系，这就实现了可重复读了，那这个照片是什么时候生成的呢？不是开启事务的时候，是当你第一次执行select的时候，也就是说，当A开启了事务，然后没有执行任何操作，这时候B-insert了一条数据然后commit-这时候A执行-select，那么返回的数据中就会有B添加的那条数据……之后无论再有其他事务commit都没有关系，因为照片已经生成了，而且不会再生成了，以后都会参考这张照片。"><a href="#当你执行select-之后，在A与B事务中都会返回4条一样的数据，这是不用想的，当执行select的时候，innodb默认会执行快照读，相当于就是给你目前的状态找了一张照片，以后执行select-的时候就会返回当前照片里面的数据，当其他事务提交了也对你不造成影响，和你没关系，这就实现了可重复读了，那这个照片是什么时候生成的呢？不是开启事务的时候，是当你第一次执行select的时候，也就是说，当A开启了事务，然后没有执行任何操作，这时候B-insert了一条数据然后commit-这时候A执行-select，那么返回的数据中就会有B添加的那条数据……之后无论再有其他事务commit都没有关系，因为照片已经生成了，而且不会再生成了，以后都会参考这张照片。" class="headerlink" title="当你执行select *之后，在A与B事务中都会返回4条一样的数据，这是不用想的，当执行select的时候，innodb默认会执行快照读，相当于就是给你目前的状态找了一张照片，以后执行select 的时候就会返回当前照片里面的数据，当其他事务提交了也对你不造成影响，和你没关系，这就实现了可重复读了，那这个照片是什么时候生成的呢？不是开启事务的时候，是当你第一次执行select的时候，也就是说，当A开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有B添加的那条数据……之后无论再有其他事务commit都没有关系，因为照片已经生成了，而且不会再生成了，以后都会参考这张照片。"></a>当你执行select *之后，在A与B事务中都会返回4条一样的数据，这是不用想的，当执行select的时候，innodb默认会执行快照读，相当于就是给你目前的状态找了一张照片，以后执行select 的时候就会返回当前照片里面的数据，当其他事务提交了也对你不造成影响，和你没关系，这就实现了可重复读了，那这个照片是什么时候生成的呢？不是开启事务的时候，是当你第一次执行select的时候，也就是说，当A开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有B添加的那条数据……之后无论再有其他事务commit都没有关系，因为照片已经生成了，而且不会再生成了，以后都会参考这张照片。</h4><h3 id="测试-当前数据库表的数据如下"><a href="#测试-当前数据库表的数据如下" class="headerlink" title="测试:当前数据库表的数据如下:"></a>测试:当前数据库表的数据如下:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| id | name | phone       |</span><br><span class="line">|  1 | pan  | 12345678912 |</span><br><span class="line">|  2 | liu  | 12345678945 |</span><br><span class="line">|  3 | han  | 45678912354 |</span><br></pre></td></tr></table></figure><h3 id="ClientA"><a href="#ClientA" class="headerlink" title="ClientA:"></a>ClientA:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set autocommit = 0; //关闭自动事务提交</span><br><span class="line">select * from user;</span><br><span class="line">//此处查询的数据还是刚开始的那些数据,但此处A事务并没提交</span><br><span class="line">| id | name | phone       |</span><br><span class="line">|  1 | pan  | 12345678912 |</span><br><span class="line">|  2 | liu  | 12345678945 |</span><br><span class="line">|  3 | han  | 45678912354 |</span><br></pre></td></tr></table></figure><h3 id="ClientB"><a href="#ClientB" class="headerlink" title="ClientB:"></a>ClientB:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert into user(name,phone) values(&apos;sb&apos;,&apos;45678912345&apos;);   //自动提交事务B,插入了一条数据</span><br><span class="line">select * from user;</span><br><span class="line">//数据已经成功插入了</span><br><span class="line">| id | name | phone       |</span><br><span class="line">|  1 | pan  | 12345678912 |</span><br><span class="line">|  2 | liu  | 12345678945 |</span><br><span class="line">|  3 | han  | 45678912354 |</span><br><span class="line">|  4 | sb   | 45678912345 |</span><br></pre></td></tr></table></figure><h3 id="ClientA-1"><a href="#ClientA-1" class="headerlink" title="ClientA:"></a>ClientA:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//还处于上面的事务中</span><br><span class="line">select * from user;</span><br><span class="line">//此处查询的数据还是刚开始的那些数据,但此处A事务并没提交</span><br><span class="line">| id | name | phone       |</span><br><span class="line">|  1 | pan  | 12345678912 |</span><br><span class="line">|  2 | liu  | 12345678945 |</span><br><span class="line">|  3 | han  | 45678912354 |</span><br><span class="line">//现在提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h3 id="ClientA-2"><a href="#ClientA-2" class="headerlink" title="ClientA:"></a>ClientA:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br><span class="line">| id | name | phone       |</span><br><span class="line">|  1 | pan  | 12345678912 |</span><br><span class="line">|  2 | liu  | 12345678945 |</span><br><span class="line">|  3 | han  | 45678912354 |</span><br><span class="line">|  4 | sb   | 45678912345 |</span><br><span class="line">//更新为最新的数据,说明了在原来事务A中select查询时已经生成了一张快照,</span><br><span class="line">//在事务没有提交时,不管其他事务对该数据如何操作都不会受影响</span><br></pre></td></tr></table></figure><h3 id="2、update、insert、delete-当前读"><a href="#2、update、insert、delete-当前读" class="headerlink" title="2、update、insert、delete 当前读"></a>2、update、insert、delete 当前读</h3><p>  当你执行这几个操作的时候默认会执行当前读，也就是会读取最新的记录，也就是别的事务提交的数据你也可以看到，这样很好理解啊，假设你要update一个记录，另一个事务已经delete这条数据并且commit了，这样不是会产生冲突吗，所以你update的时候肯定要知道最新的信息啊。在这里介绍一下update的过程吧，首先会执行当前读，然后把返回的数据加锁，之后执行update。加锁是防止别的事务在这个时候对这条记录做什么，默认加的是排他锁，也就是你读都不可以，这样就可以保证数据不会出错了。但注意一点，就算你这里加了写锁，别的事务也还是能访问的，是不是很奇怪？数据库采取了一致性非锁定读，别的事务会去读取一个快照数据。<br>  innodb默认隔离级别是RR， 是通过MVVC来实现了，读方式有两种，执行select的时候是快照读，其余是当前读，所以，mvvc不能根本上解决幻读的情况</p><h3 id="测试-当前user表中有四条数据"><a href="#测试-当前user表中有四条数据" class="headerlink" title="测试:当前user表中有四条数据"></a>测试:当前user表中有四条数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| id | name | phone       |</span><br><span class="line">|  1 | pan  | 12345678912 |</span><br><span class="line">|  2 | liu  | 12345678945 |</span><br><span class="line">|  3 | han  | 45678912354 |</span><br><span class="line">|  4 | sb   | 45678912345 |</span><br></pre></td></tr></table></figure><h3 id="ClientA-使用for-update来触发当前读"><a href="#ClientA-使用for-update来触发当前读" class="headerlink" title="ClientA:使用for update来触发当前读"></a>ClientA:使用for update来触发当前读</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id =3 for update;</span><br></pre></td></tr></table></figure><h3 id="ClientB-删除ClientA锁读取的那条数据"><a href="#ClientB-删除ClientA锁读取的那条数据" class="headerlink" title="ClientB:删除ClientA锁读取的那条数据"></a>ClientB:删除ClientA锁读取的那条数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from user where id = 3;</span><br><span class="line">----B--会阻塞住,如果A长时间不释放锁的话B就超时</span><br></pre></td></tr></table></figure><h3 id="该实例证明了A执行的当前读是加了X-排它锁-锁"><a href="#该实例证明了A执行的当前读是加了X-排它锁-锁" class="headerlink" title="该实例证明了A执行的当前读是加了X(排它锁)锁;"></a>该实例证明了A执行的当前读是加了X(排它锁)锁;</h3><h3 id="MVCC实现的快照读与当前读的底层原理"><a href="#MVCC实现的快照读与当前读的底层原理" class="headerlink" title="MVCC实现的快照读与当前读的底层原理:"></a>MVCC实现的快照读与当前读的底层原理:</h3><h3 id="在MVCC中的会默认地帮数据表的每条行数据都加上两个隐藏属性列"><a href="#在MVCC中的会默认地帮数据表的每条行数据都加上两个隐藏属性列" class="headerlink" title="在MVCC中的会默认地帮数据表的每条行数据都加上两个隐藏属性列:"></a>在MVCC中的会默认地帮数据表的每条行数据都加上两个隐藏属性列:</h3><img src="http://106.15.204.187:8888/group1/M00/00/00/rBEKH12etoWAFFGyAAA7noQxWmI604.png" style="zoom:80%;"><p>这里要引入系统版本号,当一个新事务开始的时候就会将当前的系统版本号作为当前事务id,然后系统版本号就自增1,然后删除时间默认刚开始是Undefine.然后MVCC在(RR)的隔离级别下就能保证了快照读和当前读,下面就使用一个实例来说明:</p><h3 id="测试-当前student表中无数据"><a href="#测试-当前student表中无数据" class="headerlink" title="测试:当前student表中无数据"></a>测试:当前student表中无数据</h3><h3 id="系统版本号从1开始"><a href="#系统版本号从1开始" class="headerlink" title="系统版本号从1开始:"></a>系统版本号从1开始:</h3><h3 id="ClientA-往当前表中插入两条数据"><a href="#ClientA-往当前表中插入两条数据" class="headerlink" title="ClientA:往当前表中插入两条数据:"></a>ClientA:往当前表中插入两条数据:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into student(name) values(&apos;pan&apos;);</span><br><span class="line">insert into student(name) values(&apos;li&apos;);</span><br><span class="line">insert into student(name) values(&apos;it&apos;);</span><br></pre></td></tr></table></figure><h3 id="对应的三条数据的属性"><a href="#对应的三条数据的属性" class="headerlink" title="对应的三条数据的属性:"></a>对应的三条数据的属性:</h3><img src="http://106.15.204.187:8888/group1/M00/00/00/rBEKH12eu2WAM3l9AAA7Drw9GWs554.png" style="zoom:60%;"><h3 id="ClientB-1"><a href="#ClientB-1" class="headerlink" title="ClientB:"></a>ClientB:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from student; -------s1</span><br><span class="line">select * from student; -------s2</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h3 id="ClientC-在执行到事务id为2的事务的s1语句之后-就有第三个事务进来-执行如下操作"><a href="#ClientC-在执行到事务id为2的事务的s1语句之后-就有第三个事务进来-执行如下操作" class="headerlink" title="ClientC: 在执行到事务id为2的事务的s1语句之后,就有第三个事务进来,执行如下操作"></a>ClientC: 在执行到事务id为2的事务的s1语句之后,就有第三个事务进来,执行如下操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into student(name) values(&apos;s&apos;);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><img src="http://106.15.204.187:8888/group1/M00/00/00/rBEKH12f5l2AAte2AAA17YNpAVM268.png" style="zoom:60%;"><h3 id="那么插入的id-4的这条数据的事务id就是当前系统版本号-也就是3-当事务B继续执行时时s2的语句进行查询的时候-由于只能查询出小于或等于当前事务id的数据-所以事务C所插入的数据是无法插查询到的"><a href="#那么插入的id-4的这条数据的事务id就是当前系统版本号-也就是3-当事务B继续执行时时s2的语句进行查询的时候-由于只能查询出小于或等于当前事务id的数据-所以事务C所插入的数据是无法插查询到的" class="headerlink" title="那么插入的id=4的这条数据的事务id就是当前系统版本号,也就是3.当事务B继续执行时时s2的语句进行查询的时候,由于只能查询出小于或等于当前事务id的数据,所以事务C所插入的数据是无法插查询到的."></a>那么插入的id=4的这条数据的事务id就是当前系统版本号,也就是3.当事务B继续执行时时s2的语句进行查询的时候,由于只能查询出小于或等于当前事务id的数据,所以事务C所插入的数据是无法插查询到的.</h3><h3 id="ClientD-当事务B执行完s1语句的查询之后-就有事务D进来对数据进行如下操作"><a href="#ClientD-当事务B执行完s1语句的查询之后-就有事务D进来对数据进行如下操作" class="headerlink" title="ClientD:当事务B执行完s1语句的查询之后,就有事务D进来对数据进行如下操作:"></a>ClientD:当事务B执行完s1语句的查询之后,就有事务D进来对数据进行如下操作:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">delete from student where id = 1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><img src="http://106.15.204.187:8888/group1/M00/00/00/rBEKH12f6pGAEkTZAAAyrSxeLys166.png" style="zoom: 50%;"><p>当执行完这个语句之后,由于当前事务id为4,所以在所修改的语句中定义删除ID为当前事务ID;所以在在事务B执行s2查询语句的时候就由于当前事务版本号为2,所以无法看到事务版本号为4的这个数据;</p><p>ClientE:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update student set name = &apos;l&apos; where id =  3;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h3 id="update的操作需要进行两步操作"><a href="#update的操作需要进行两步操作" class="headerlink" title="update的操作需要进行两步操作:"></a>update的操作需要进行两步操作:</h3><h3 id="1-读取读取出原来的行数据-并且加上锁"><a href="#1-读取读取出原来的行数据-并且加上锁" class="headerlink" title="1.读取读取出原来的行数据,并且加上锁;"></a>1.读取读取出原来的行数据,并且加上锁;</h3><h3 id="2-修改当前数据-并且将原来的行数据的删除时间定义为当前事务ID-将要执行修改的数据的事务ID为当前事务的ID-后面有证明为什么不是当前系统版本号-而是当前事务ID-然后原来的行数据就会写入到undo-log里面-当其他事务要查询这条数据时-先从read-view中查到可查询的事务ID然后该事务ID的-然后存在一个回滚指针指向undo-log修改前的行数据"><a href="#2-修改当前数据-并且将原来的行数据的删除时间定义为当前事务ID-将要执行修改的数据的事务ID为当前事务的ID-后面有证明为什么不是当前系统版本号-而是当前事务ID-然后原来的行数据就会写入到undo-log里面-当其他事务要查询这条数据时-先从read-view中查到可查询的事务ID然后该事务ID的-然后存在一个回滚指针指向undo-log修改前的行数据" class="headerlink" title="2.修改当前数据,并且将原来的行数据的删除时间定义为当前事务ID,将要执行修改的数据的事务ID为当前事务的ID(后面有证明为什么不是当前系统版本号,而是当前事务ID);然后原来的行数据就会写入到undo.log里面,当其他事务要查询这条数据时,先从read_view中查到可查询的事务ID然后该事务ID的,然后存在一个回滚指针指向undo.log修改前的行数据."></a>2.修改当前数据,并且将原来的行数据的删除时间定义为当前事务ID,将要执行修改的数据的事务ID为当前事务的ID(后面有证明为什么不是当前系统版本号,而是当前事务ID);然后原来的行数据就会写入到undo.log里面,当其他事务要查询这条数据时,先从read_view中查到可查询的事务ID然后该事务ID的,然后存在一个回滚指针指向undo.log修改前的行数据.</h3><img src="http://106.15.204.187:8888/group1/M00/00/00/rBEKH12f9RmAR9wWAABCkDz2mfQ080.png" style="zoom: 50%;"><h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>　　<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read" target="_blank" rel="noopener">consistent read</a> （一致性读），InnoDB用多版本来提供查询数据库在某个时间点的快照。如果隔离级别是REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中第一个这样的读读到的快照；如果是READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己刷新的快照版本。Consistent read（一致性读）是READ COMMITTED和REPEATABLE READ隔离级别下普通SELECT语句默认的模式。一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基于Innodb存储引擎的快照读与当前读分析&quot;&gt;&lt;a href=&quot;#基于Innodb存储引擎的快照读与当前读分析&quot; class=&quot;headerlink&quot; title=&quot;基于Innodb存储引擎的快照读与当前读分析:&quot;&gt;&lt;/a&gt;基于Innodb存储引擎的快照读与当前
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://Homeofpan.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://Homeofpan.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的InnoDb引擎的索引原理</title>
    <link href="http://Homeofpan.github.io/2019/10/08/Mysql%E7%9A%84InnoDb%E5%BC%95%E6%93%8E%E7%9A%84%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>http://Homeofpan.github.io/2019/10/08/Mysql的InnoDb引擎的索引原理/</id>
    <published>2019-10-08T12:25:50.000Z</published>
    <updated>2019-10-08T15:34:05.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引-聚集索引和非聚集索引"><a href="#索引-聚集索引和非聚集索引" class="headerlink" title="索引:聚集索引和非聚集索引"></a>索引:聚集索引和非聚集索引</h3><h4 id="聚集索引-在InnoDb中-Mysql默认是按照表的主键来按顺序的存储数据-通过表的主键作为聚集索引-构造一颗索引的B-树-叶子节点的存放的数据就是表的行数据-因为聚集索引是按照B-数来排序的-所以主键在一个表中只能存放一个-InnoBd的默认聚集索引就是主键"><a href="#聚集索引-在InnoDb中-Mysql默认是按照表的主键来按顺序的存储数据-通过表的主键作为聚集索引-构造一颗索引的B-树-叶子节点的存放的数据就是表的行数据-因为聚集索引是按照B-数来排序的-所以主键在一个表中只能存放一个-InnoBd的默认聚集索引就是主键" class="headerlink" title="聚集索引: 在InnoDb中,Mysql默认是按照表的主键来按顺序的存储数据.通过表的主键作为聚集索引,构造一颗索引的B+树,叶子节点的存放的数据就是表的行数据.因为聚集索引是按照B+数来排序的,所以主键在一个表中只能存放一个.InnoBd的默认聚集索引就是主键."></a>聚集索引: 在InnoDb中,Mysql默认是按照表的主键来按顺序的存储数据.通过表的主键作为聚集索引,构造一颗索引的B+树,叶子节点的存放的数据就是表的行数据.因为聚集索引是按照B+数来排序的,所以主键在一个表中只能存放一个.InnoBd的默认聚集索引就是主键.</h4><blockquote><p>如果没有设置主键?</p><p>Innodb还会去找表中是否存在唯一标识的表的字段?</p><p>如果都没有的话,innodb就会存在三个隐藏列:</p><p>DB_ROW_ID做为隐藏的主键……</p></blockquote><p>也就是说Innodb中是一定保证存在主键</p><blockquote><p>自增主键和uuid作为主键的区别，由于主键使用了聚簇索引，如果主键是自增id,那么对应的数据一定也是相邻地存放在磁盘上的，写入性能比较高。如果是uuid的形式，频繁的插入会使innodb频繁地移动磁盘块，写入性能就比较低了。</p></blockquote><h3 id="聚集索引的原理"><a href="#聚集索引的原理" class="headerlink" title="聚集索引的原理:"></a>聚集索引的原理:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| id | user_name | user_phone  |</span><br><span class="line">| 1  | ss        | 455         |</span><br><span class="line">| 3  | pan       | 12345678911 |</span><br><span class="line">| 5  | sb        | 45678912345 |</span><br></pre></td></tr></table></figure><h3 id="非聚集索引的原理"><a href="#非聚集索引的原理" class="headerlink" title="非聚集索引的原理:"></a>非聚集索引的原理:</h3><p>运行下面的sql语句建立索引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on user(user_name);</span><br></pre></td></tr></table></figure><h5 id="为表的其他字段建立索引-并且非聚集索引的B-树的叶子节点都不是真实的存放在磁盘中的数据-只存放着主键索引-聚集索引-和该索引字段的数据-查找该表的所有数据时-如果像一下的sql语句查看"><a href="#为表的其他字段建立索引-并且非聚集索引的B-树的叶子节点都不是真实的存放在磁盘中的数据-只存放着主键索引-聚集索引-和该索引字段的数据-查找该表的所有数据时-如果像一下的sql语句查看" class="headerlink" title="为表的其他字段建立索引,并且非聚集索引的B+树的叶子节点都不是真实的存放在磁盘中的数据,只存放着主键索引(聚集索引)和该索引字段的数据;查找该表的所有数据时,如果像一下的sql语句查看:"></a>为表的其他字段建立索引,并且非聚集索引的B+树的叶子节点都不是真实的存放在磁盘中的数据,只存放着主键索引(聚集索引)和该索引字段的数据;查找该表的所有数据时,如果像一下的sql语句查看:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where user_name = &apos;pan&apos;;</span><br></pre></td></tr></table></figure><p>那就先从user_name建立的索引B+数开始索引,当遍历到user_name=’pan’的时候,就会找到它对应的主键索引值,用该主键索引值从聚集索引B+树中查看出磁盘中真实所放的行数据.</p><h3 id="但是只是查看该索引值的时候-就会直接返回B-树中的值"><a href="#但是只是查看该索引值的时候-就会直接返回B-树中的值" class="headerlink" title="但是只是查看该索引值的时候:就会直接返回B+树中的值"></a>但是只是查看该索引值的时候:就会直接返回B+树中的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_name from user where user_name = &apos;pan&apos;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引-聚集索引和非聚集索引&quot;&gt;&lt;a href=&quot;#索引-聚集索引和非聚集索引&quot; class=&quot;headerlink&quot; title=&quot;索引:聚集索引和非聚集索引&quot;&gt;&lt;/a&gt;索引:聚集索引和非聚集索引&lt;/h3&gt;&lt;h4 id=&quot;聚集索引-在InnoDb中-Mysql默认
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://Homeofpan.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://Homeofpan.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>spring容器初始化</title>
    <link href="http://Homeofpan.github.io/2019/10/08/spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://Homeofpan.github.io/2019/10/08/spring容器初始化/</id>
    <published>2019-10-08T08:02:52.000Z</published>
    <updated>2019-10-09T06:13:34.209Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring容器的初始化过程"><a href="#Spring容器的初始化过程" class="headerlink" title="Spring容器的初始化过程"></a>Spring容器的初始化过程</h3><p><img src="//Homeofpan.github.io/2019/10/08/spring容器初始化/D:%5Cblog%5Csource_posts%5Cspring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%5C1.jpg" alt="流程图"></p><h4 id="1-执行构造函数-实例化一个容器对象"><a href="#1-执行构造函数-实例化一个容器对象" class="headerlink" title="1.执行构造函数,实例化一个容器对象:"></a>1.执行构造函数,实例化一个容器对象:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建容器对象,并且从spring的所有配置文件中加载definitions</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">//使用parent创建</span></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">//将spring有关的配置文件都设置到configLocations</span></span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            <span class="comment">//刷新容器</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.刷新创建的ClasspathXmlApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 1.Prepare this context for refreshing.刷新容器前的预处理</span></span><br><span class="line">            <span class="comment">//设置容器的启动时间和加载自定义的一些数据配置文件:*.properties.......</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">            <span class="comment">// 2.</span></span><br><span class="line">            <span class="comment">//   (a)创建ioc容器 (DefaultListableBeanFactory)</span></span><br><span class="line">            <span class="comment">//    (b)加载xml的信息 (最后转存为Document对象)</span></span><br><span class="line">            <span class="comment">//    (c)对Document对象解析,在这里完成对BeanDefinition的注册和加载</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            <span class="comment">// 3.对IOC容器的一些预处理</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                <span class="comment">// STEP 4： 允许在AbstractApplicationContext的子类中对BeanFactory进行后置处理，                        //      postProcessBeanFactory()这个方法是个空实现。</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">//STEP 5： 调用BeanFactoryPostProcessor后置处理器处理BeanFactory的实例                                     （BeanDefinition）</span></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">//STEP6  1.注册BeanPostProcessor后置处理器</span></span><br><span class="line">                 <span class="comment">//  2.b）BeanPostProcessors后置处理器用于拦截bean的创建，对创建后的bean实例进行处理</span></span><br><span class="line">               registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                <span class="comment">//STEP7 :初始化一些消息资源</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                <span class="comment">// STEP 8： </span></span><br><span class="line">                <span class="comment">//      a)  初始化应用事件广播器</span></span><br><span class="line">                <span class="comment">//      b)  表明Spring内部基于事件机制</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">                <span class="comment">//STEP9</span></span><br><span class="line">                <span class="comment">//初始化一些特殊的bean</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                <span class="comment">//STEP10 :</span></span><br><span class="line">                <span class="comment">// 遍历寻找listener并且注册</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                <span class="comment">//STEP11</span></span><br><span class="line">                <span class="comment">//       实例化剩余(非实例化的)bean</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                <span class="comment">//STEP12 : 完成容器的刷新,并且发布对应的事件</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Beanfactory的源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure><h3 id="进入AbstractApplication的obtainFreshBeanFactory-的方法"><a href="#进入AbstractApplication的obtainFreshBeanFactory-的方法" class="headerlink" title="进入AbstractApplication的obtainFreshBeanFactory()的方法:"></a>进入AbstractApplication的obtainFreshBeanFactory()的方法:</h3><h3 id="用于创建一个新的Ioc容器-这个Ioc容器就是DefaultListableBeanFactory"><a href="#用于创建一个新的Ioc容器-这个Ioc容器就是DefaultListableBeanFactory" class="headerlink" title="用于创建一个新的Ioc容器,这个Ioc容器就是DefaultListableBeanFactory"></a>用于创建一个新的Ioc容器,这个Ioc容器就是DefaultListableBeanFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过该方法刷新BeanFactory,并且创建一个ioc容器</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line">         <span class="comment">//获取refreshBeanFactory()创建的ioc容器</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进入AbstractApplication的refreshBeanFactory-方法中"><a href="#进入AbstractApplication的refreshBeanFactory-方法中" class="headerlink" title="进入AbstractApplication的refreshBeanFactory()方法中:"></a>进入AbstractApplication的refreshBeanFactory()方法中:</h3><h4 id="初始化一个BeanFactory"><a href="#初始化一个BeanFactory" class="headerlink" title="初始化一个BeanFactory"></a>初始化一个BeanFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation performs an actual refresh of this context's underlying</span></span><br><span class="line"><span class="comment"> * bean factory, shutting down the previous bean factory (if any) and</span></span><br><span class="line"><span class="comment"> * initializing a fresh bean factory for the next phase of the context's lifecycle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="comment">//判断是否已经存在BeanFactory</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">       <span class="comment">//销毁上一个BeanFactory</span></span><br><span class="line">destroyBeans();</span><br><span class="line">       <span class="comment">//并且关闭    </span></span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//创建一个BeanFactory的实例(DefaultListableBeanFactory)</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line">           <span class="comment">//设置BeanFactory的属性:是否允许BeanDefinition的覆盖和循环依赖</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">           <span class="comment">//加载spring的xml文件的BeanDefinition</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载BeanDefinition流程分析"><a href="#加载BeanDefinition流程分析" class="headerlink" title="加载BeanDefinition流程分析:"></a>加载BeanDefinition流程分析:</h3><h3 id="进入AbstractXmlApplicationContext的loadBeanDefinitions-beanFactory-方法"><a href="#进入AbstractXmlApplicationContext的loadBeanDefinitions-beanFactory-方法" class="headerlink" title="进入AbstractXmlApplicationContext的loadBeanDefinitions(beanFactory)方法:"></a>进入AbstractXmlApplicationContext的loadBeanDefinitions(beanFactory)方法:</h3><h4 id="gt-创建一个XmlBeanDefinitionReader-真正地去完成BeanDefinition的注册和加载"><a href="#gt-创建一个XmlBeanDefinitionReader-真正地去完成BeanDefinition的注册和加载" class="headerlink" title="&gt;创建一个XmlBeanDefinitionReader,真正地去完成BeanDefinition的注册和加载"></a>&gt;创建一个XmlBeanDefinitionReader,真正地去完成BeanDefinition的注册和加载</h4><h4 id="gt-配置XmlBeanDefinitionReader的属性"><a href="#gt-配置XmlBeanDefinitionReader的属性" class="headerlink" title="&gt;配置XmlBeanDefinitionReader的属性"></a>&gt;配置XmlBeanDefinitionReader的属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Loads the bean definitions via an XmlBeanDefinitionReader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.xml.XmlBeanDefinitionReader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #initBeanDefinitionReader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadBeanDefinitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory</span></span><br><span class="line">        <span class="comment">//为工厂创建一个读取xml的一个reader</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line"><span class="comment">// resource loading environment.</span></span><br><span class="line">         <span class="comment">//设置reader的一些环境属性</span></span><br><span class="line">beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line"><span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">         <span class="comment">//允许自定义的reader来读取xml的BeanDefinition</span></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">         <span class="comment">//委托xml阅读器去加载xml的BeanDefinitions信息</span></span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException,      IOException </span>&#123;</span><br><span class="line">         <span class="comment">//获取资源的位置</span></span><br><span class="line">         <span class="comment">//getConfigResources是一个空实现,需要子类去实现</span></span><br><span class="line">         <span class="comment">//获取ClasspathXMLApplicationContext的父类AbstractXmlApplicationContext的</span></span><br><span class="line">         <span class="comment">//配置文件信息,默认返回null</span></span><br><span class="line">Resource[] configResources = getConfigResources();</span><br><span class="line"><span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">reader.loadBeanDefinitions(configResources);</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">//如果用户指定了spring的xml配置文件的位置就获取用户的自定义配置文件</span></span><br><span class="line">         <span class="comment">//否则就加载父类指定的默认加载位置,默认返回null</span></span><br><span class="line">String[] configLocations = getConfigLocations();</span><br><span class="line"><span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">//该方法的参数就是我们在new一个容器实例传入的一个参数,代表spring的xml配置文件的地方</span></span><br><span class="line">             <span class="comment">//该方法真正地去读取xml的beanDefinition的信息,并且返回读取的一个计数值,来表示读取了多少个</span></span><br><span class="line">             <span class="comment">//位置的xml</span></span><br><span class="line">reader.loadBeanDefinitions(configLocations);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loadBeanDefinitions最终来到了XmlBeanDefinitionReader的doLoadBeanDefinitions方法："><a href="#loadBeanDefinitions最终来到了XmlBeanDefinitionReader的doLoadBeanDefinitions方法：" class="headerlink" title="loadBeanDefinitions最终来到了XmlBeanDefinitionReader的doLoadBeanDefinitions方法："></a>loadBeanDefinitions最终来到了<strong>XmlBeanDefinitionReader</strong>的doLoadBeanDefinitions方法：</h3><h3 id="gt-对XML文件进行解析"><a href="#gt-对XML文件进行解析" class="headerlink" title="&gt;对XML文件进行解析"></a>&gt;对XML文件进行解析</h3><h3 id="gt-完成BeanDefinition对象的加载与注册"><a href="#gt-完成BeanDefinition对象的加载与注册" class="headerlink" title="&gt;完成BeanDefinition对象的加载与注册"></a>&gt;完成BeanDefinition对象的加载与注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//将XML转换成document对象</span></span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">           <span class="comment">//BeanDefinition对象的加载与注册</span></span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<strong>XmlBeanDefinitionReader</strong><code>registerBeanDefinitions</code></p><ul><li>创建<strong>DefaultBeanDefinitionDocumentReader</strong>用来解析Document对象。</li><li>获得容器中已注册的BeanDefinition数量</li><li>委托给<strong>DefaultBeanDefinitionDocumentReader</strong>来完成BeanDefinition的加载、注册工作。</li><li>统计新注册的BeanDefinition数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span>            BeanDefinitionStoreException </span>&#123;</span><br><span class="line">         <span class="comment">//创建一个BeanDefinitionDocumentReader来解析Document对象的BeanDefinition信息</span></span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">        <span class="comment">//获取容器已经存在的BeanDefinition的数量</span></span><br><span class="line"><span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">        <span class="comment">//返回注册后的容器中新增的BeanDefintion的个数</span></span><br><span class="line"><span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进入<strong>DefaultBeanDefinitionDocumentReader</strong></p><ul><li>获得Document的根元素<beans>标签</beans></li><li>真正实现BeanDefinition解析和注册工作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">        <span class="comment">//从document对象中获取&lt;bean&gt;的标签</span></span><br><span class="line">Element root = doc.getDocumentElement();</span><br><span class="line">        <span class="comment">//对这些标签的真正注册和解析</span></span><br><span class="line">doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接下来就是解析…-的一些标签的过程-源码省略"><a href="#接下来就是解析…-的一些标签的过程-源码省略" class="headerlink" title="接下来就是解析….的一些标签的过程(源码省略):"></a>接下来就是解析<bean>….的一些标签的过程(源码省略):</bean></h3><h4 id="gt-1-从根标签开始遍历所有的标签"><a href="#gt-1-从根标签开始遍历所有的标签" class="headerlink" title="&gt; 1.从根标签开始遍历所有的标签"></a>&gt; 1.从根标签开始遍历所有的标签</h4><h4 id="gt-2-如果存在默认的标签-…-的标签就进行解析"><a href="#gt-2-如果存在默认的标签-…-的标签就进行解析" class="headerlink" title="&gt; 2.如果存在默认的标签(…)的标签就进行解析"></a>&gt; 2.如果存在默认的标签(<bean>…)的标签就进行解析</bean></h4><h4 id="gt-3-否则就去解析自定义的标签"><a href="#gt-3-否则就去解析自定义的标签" class="headerlink" title="&gt; 3.否则就去解析自定义的标签"></a>&gt; 3.否则就去解析自定义的标签</h4><h4 id="gt-4-解析标签里面的所有属性-id-name-class…"><a href="#gt-4-解析标签里面的所有属性-id-name-class…" class="headerlink" title="&gt;  4.解析标签里面的所有属性(id,name,class….)"></a>&gt;  4.解析<bean>标签里面的所有属性(id,name,class….)</bean></h4><h3 id="实例化剩余的-非懒加载的-bean"><a href="#实例化剩余的-非懒加载的-bean" class="headerlink" title="实例化剩余的(非懒加载的)bean"></a>实例化剩余的(非懒加载的)bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">        <span class="comment">//重点方法:实例化容器剩余(非懒加载的)bean,并且ioc,DI和AOP都发生在这个方法里面</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring容器的初始化过程&quot;&gt;&lt;a href=&quot;#Spring容器的初始化过程&quot; class=&quot;headerlink&quot; title=&quot;Spring容器的初始化过程&quot;&gt;&lt;/a&gt;Spring容器的初始化过程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;//Homeofpan.
      
    
    </summary>
    
    
      <category term="ssm" scheme="http://Homeofpan.github.io/categories/ssm/"/>
    
    
      <category term="spring" scheme="http://Homeofpan.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码分析</title>
    <link href="http://Homeofpan.github.io/2019/10/05/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://Homeofpan.github.io/2019/10/05/ThreadLocal源码分析/</id>
    <published>2019-10-05T09:30:51.000Z</published>
    <updated>2019-10-05T10:03:13.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Threadlocal的源码分析"><a href="#Threadlocal的源码分析" class="headerlink" title="Threadlocal的源码分析"></a>Threadlocal的源码分析</h3><p>首先ThreadLocal官网给出的定义是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This class provides thread-local variables.</span></span><br><span class="line"><span class="comment">*These variables differ from * their normal counterparts in that each thread that accesses one (via its * &#123;<span class="doctag">@code</span> get&#125; or &#123;<span class="doctag">@code</span> set&#125; method) has its own, independently initialized * copy of the variable.</span></span><br><span class="line"><span class="comment">*&#123;<span class="doctag">@code</span> ThreadLocal&#125; instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID).</span></span><br></pre></td></tr></table></figure><p>意思是这个类时提供给每一个线程的一个变量,每个线程存放在ThreadLocal中的变量都是独立的,不能被其他线程所访问.</p><h3 id="set-方法的源码分析"><a href="#set-方法的源码分析" class="headerlink" title="set()方法的源码分析"></a>set()方法的源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    获取ThreadLocal中的内部类的map</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//判断获取的map是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//如果存在就直接以当前ThreadLocal为key,value为value插入map</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则创建一个map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set方法实际执行的是Threadlocal里面的一个内部类的set方法"><a href="#set方法实际执行的是Threadlocal里面的一个内部类的set方法" class="headerlink" title="set方法实际执行的是Threadlocal里面的一个内部类的set方法"></a>set方法实际执行的是Threadlocal里面的一个内部类的set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//ThreadLocalMap的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Entry键值对数组</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">//获取数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环遍历找到对应的ThreadLocal</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果找到该key,就将新的value进行覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有找到的话,,就直接将新的key,value插入覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//调用该方法进行对原来的key= null的value进行清除,有利于Gc清除</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果超过了该Entry[]的size;</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="comment">//长度++</span></span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">//需要重新获取哈希</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当存放的Entry数组的size满了之后就要执行rehash-这里的逻辑"><a href="#当存放的Entry数组的size满了之后就要执行rehash-这里的逻辑" class="headerlink" title="当存放的Entry数组的size满了之后就要执行rehash()这里的逻辑"></a>当存放的Entry数组的size满了之后就要执行rehash()这里的逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Re-pack and/or re-size the table. First scan the entire</span></span><br><span class="line"><span class="comment"> * table removing stale entries. If this doesn't sufficiently</span></span><br><span class="line"><span class="comment"> * shrink the size of the table, double the table size.</span></span><br><span class="line"><span class="comment"> *先对该table进行一次旧数据的清除,如果清除完成之后还是超过threshold值</span></span><br><span class="line"><span class="comment"> *则将重新调整为原来的两倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries(); <span class="comment">//清除旧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当进行完上面的方法之后-就要进行Entry-数组的扩容"><a href="#当进行完上面的方法之后-就要进行Entry-数组的扩容" class="headerlink" title="当进行完上面的方法之后,就要进行Entry[]数组的扩容"></a>当进行完上面的方法之后,就要进行Entry[]数组的扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Double the capacity of the table.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Entry[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">     <span class="comment">//调整table长度为原来的两倍</span></span><br><span class="line">     <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">     Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">     <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//将原来table的Entry全部复制到newTable</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">         Entry e = oldTab[j];</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">             <span class="comment">//如果key为空,将其value设为null</span></span><br><span class="line">             <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//获取哈希值</span></span><br><span class="line">                 <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                 <span class="comment">//如果当前位置已经存放entry</span></span><br><span class="line">                 <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                     <span class="comment">//线性表往后查询,找到一个没有存放entry的位置h</span></span><br><span class="line">                     h = nextIndex(h, newLen);</span><br><span class="line">                 newTab[h] = e;</span><br><span class="line">                 count++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//设置新的threadshold值</span></span><br><span class="line">     setThreshold(newLen);</span><br><span class="line">     <span class="comment">//重新设置当前entry[]已经存放数据的长度</span></span><br><span class="line">     size = count;</span><br><span class="line">     <span class="comment">//更新当前Entry[]</span></span><br><span class="line">     table = newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="二-get方法的源码分析"><a href="#二-get方法的源码分析" class="headerlink" title="二.get方法的源码分析"></a>二.get方法的源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//get操作 ThreadMap中的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//根据当前threadLocal的对象,获取Entry的对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">//如果不为空,则获取对应的值,并且返回</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当map为空和e为空都会进入初始化方法</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *根据key获取entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//获取哈希值,并计算出存放的位置</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="comment">//存在Entry就返回,并且entry的key为所需要的key</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            *循环查找table数组的不为null的entry,并且判断查出来的entry是否是所查找的</span></span><br><span class="line"><span class="comment">            *直到没找到就返回null</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="comment">//再次进行检查</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//删除当前数组下标的entry</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//可能原来这个key位置被其他key占用了,避免查看错误,继续递增的找下去</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果该table的位置不存在entry则直接返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 当map不存在时,创建一个map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化的value值为null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//对当前超线程的map再进一步判断,防止map已经创建了</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="comment">//当map不为空才执行该方法</span></span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//循环遍历与目标可能一样的entry</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    <span class="comment">//调用Reference的clear方法</span></span><br><span class="line">                    <span class="comment">//原理是将key值为空,利用gc进行回收</span></span><br><span class="line">                    e.clear();</span><br><span class="line">                    <span class="comment">//删除对应的下标的entry数据</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Threadlocal的源码分析&quot;&gt;&lt;a href=&quot;#Threadlocal的源码分析&quot; class=&quot;headerlink&quot; title=&quot;Threadlocal的源码分析&quot;&gt;&lt;/a&gt;Threadlocal的源码分析&lt;/h3&gt;&lt;p&gt;首先ThreadLocal官
      
    
    </summary>
    
    
    
      <category term="java并发" scheme="http://Homeofpan.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="http://Homeofpan.github.io/2019/10/05/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>http://Homeofpan.github.io/2019/10/05/我的第一篇文章/</id>
    <published>2019-10-05T07:12:26.000Z</published>
    <updated>2019-10-05T09:06:07.510Z</updated>
    
    <content type="html"><![CDATA[<h4 id="大家好"><a href="#大家好" class="headerlink" title="大家好"></a>大家好</h4><h5 id="标题二"><a href="#标题二" class="headerlink" title="标题二"></a>标题二</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system.out.println(<span class="string">"sssss"</span>);</span><br></pre></td></tr></table></figure><p>##参考文献</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;大家好&quot;&gt;&lt;a href=&quot;#大家好&quot; class=&quot;headerlink&quot; title=&quot;大家好&quot;&gt;&lt;/a&gt;大家好&lt;/h4&gt;&lt;h5 id=&quot;标题二&quot;&gt;&lt;a href=&quot;#标题二&quot; class=&quot;headerlink&quot; title=&quot;标题二&quot;&gt;&lt;/a&gt;标题二&lt;/h
      
    
    </summary>
    
    
      <category term="Testing" scheme="http://Homeofpan.github.io/categories/Testing/"/>
    
    
      <category term="java" scheme="http://Homeofpan.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://Homeofpan.github.io/2019/10/05/hello-world/"/>
    <id>http://Homeofpan.github.io/2019/10/05/hello-world/</id>
    <published>2019-10-05T07:01:28.652Z</published>
    <updated>2019-10-05T07:01:28.656Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
